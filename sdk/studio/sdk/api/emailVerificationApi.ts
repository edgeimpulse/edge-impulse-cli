/**
 * Edge Impulse API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

const PATH = require('path');
module.paths.push(PATH.join(process.cwd(), 'node_modules'));

import type { fetch as UndiciFetch, FormData as UndiciFormData, Response as UndiciResponse } from 'undici-types';

let fetch: typeof globalThis.fetch | typeof UndiciFetch;
let FormData: typeof globalThis.FormData | typeof UndiciFormData;

if (globalThis.fetch && globalThis.FormData) {
    fetch = globalThis.fetch;
    FormData = globalThis.FormData;
}
else {
    const undici = require('undici');
    fetch = undici.fetch;
    FormData = undici.FormData;
}

import { ActivateUserOrVerifyEmailRequest } from '../model/activateUserOrVerifyEmailRequest';
import { EmailValidationRequest } from '../model/emailValidationRequest';
import { EntityCreatedResponse } from '../model/entityCreatedResponse';
import { GetEmailVerificationStatusResponse } from '../model/getEmailVerificationStatusResponse';
import { RequestEmailVerificationRequest } from '../model/requestEmailVerificationRequest';
import { ValidateEmailResponse } from '../model/validateEmailResponse';
import { VerifyEmailResponse } from '../model/verifyEmailResponse';

import { ObjectSerializer, Authentication, VoidAuth, RequestOptionsType } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://studio.edgeimpulse.com/v1';

async function parseResponse(res: Response | UndiciResponse): Promise<any> {
    const ct = (res.headers.get('content-type') || '').toLowerCase();

    if (ct.includes('application/json')) return res.json();

    if (/^(image|video|audio)\/|application\/(octet-stream|zip|x-tar|cbor)/.test(ct)) {
        return Buffer.from(await res.arrayBuffer());
    }

    return res.text();
}

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum EmailVerificationApiApiKeys {
}


export type EmailVerificationApiOpts = {
    extraHeaders?: Record<string, string>;
};

export class EmailVerificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : Record<string, string> = {};
    protected _opts : EmailVerificationApiOpts = { };

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected async handleResponse(response: Response | UndiciResponse, returnType: string | undefined): Promise<any> {
        let body = await parseResponse(response);
        if (!response.ok) {
            let errorMsg;
            if (typeof body === 'object' && body !== null && 'error' in body) {
                errorMsg = body.error;
            } else {
                errorMsg = `Failed to call "${response.url}", returned ${response.status}: ` + (typeof body === 'string' ? body : JSON.stringify(body));
            }
            throw new Error(errorMsg);
        }

        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        if (typeof body.success === 'boolean' && !body.success) {
            const errString = `Failed to call "${response.url}", returned ${response.status}: ` + body.error;
            throw new Error(body.error || errString);
        }

        return body;
    }

    constructor(basePath?: string, opts?: EmailVerificationApiOpts);
    constructor(basePathOrUsername: string, opts?: EmailVerificationApiOpts, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }

        this.opts = opts ?? { };
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set opts(opts: EmailVerificationApiOpts) {
        this._opts = opts;
    }

    get opts() {
        return this._opts;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: EmailVerificationApiApiKeys, value: string | undefined) {
        (this.authentications as any)[EmailVerificationApiApiKeys[key]].apiKey = value;
    }


    /**
     * Get the status of an email verification.
     * @summary Get email verification status
     * @param emailId Unique identifier for an email verification request
     */
    public async getEmailVerificationStatus (emailId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetEmailVerificationStatusResponse> {
        const localVarPath = this.basePath + '/api/emails/{emailId}'
            .replace('{' + 'emailId' + '}', encodeURIComponent(String(emailId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'emailId' is not null or undefined


        if (emailId === null || emailId === undefined) {
            throw new Error('Required parameter emailId was null or undefined when calling getEmailVerificationStatus.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetEmailVerificationStatusResponse'
        );
    }

    /**
     * Request an email activation code to be sent to the specified email address.
     * @summary Request email verification
     * @param email Email address
     * @param requestEmailVerificationRequest 
     */
    public async requestEmailVerification (email: string, requestEmailVerificationRequest: RequestEmailVerificationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<EntityCreatedResponse> {
        const localVarPath = this.basePath + '/api/emails/{email}/request-verification'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'email' is not null or undefined


        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling requestEmailVerification.');
        }

        // verify required parameter 'requestEmailVerificationRequest' is not null or undefined


        if (requestEmailVerificationRequest === null || requestEmailVerificationRequest === undefined) {
            throw new Error('Required parameter requestEmailVerificationRequest was null or undefined when calling requestEmailVerification.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(requestEmailVerificationRequest, "RequestEmailVerificationRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'EntityCreatedResponse'
        );
    }

    /**
     * Validate whether an email is valid for sign up. Using an email that fails this check can result in the associated account missing communications and features that are distributed through email.
     * @summary Validate email for account sign-up
     * @param emailValidationRequest 
     */
    public async validateEmail (emailValidationRequest: EmailValidationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ValidateEmailResponse> {
        const localVarPath = this.basePath + '/api/emails/validate';
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'emailValidationRequest' is not null or undefined


        if (emailValidationRequest === null || emailValidationRequest === undefined) {
            throw new Error('Required parameter emailValidationRequest was null or undefined when calling validateEmail.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(emailValidationRequest, "EmailValidationRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ValidateEmailResponse'
        );
    }

    /**
     * Verify an email address using the specified verification code.
     * @summary Verify email
     * @param activateUserOrVerifyEmailRequest 
     */
    public async verifyEmail (activateUserOrVerifyEmailRequest: ActivateUserOrVerifyEmailRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<VerifyEmailResponse> {
        const localVarPath = this.basePath + '/api/emails/verify';
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'activateUserOrVerifyEmailRequest' is not null or undefined


        if (activateUserOrVerifyEmailRequest === null || activateUserOrVerifyEmailRequest === undefined) {
            throw new Error('Required parameter activateUserOrVerifyEmailRequest was null or undefined when calling verifyEmail.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(activateUserOrVerifyEmailRequest, "ActivateUserOrVerifyEmailRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'VerifyEmailResponse'
        );
    }
}

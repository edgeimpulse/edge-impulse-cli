/**
 * Edge Impulse API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

const PATH = require('path');
module.paths.push(PATH.join(process.cwd(), 'node_modules'));

import type { fetch as UndiciFetch, FormData as UndiciFormData, Response as UndiciResponse } from 'undici-types';

let fetch: typeof globalThis.fetch | typeof UndiciFetch;
let FormData: typeof globalThis.FormData | typeof UndiciFormData;

if (globalThis.fetch && globalThis.FormData) {
    fetch = globalThis.fetch;
    FormData = globalThis.FormData;
}
else {
    const undici = require('undici');
    fetch = undici.fetch;
    FormData = undici.FormData;
}

import { AutotuneDspRequest } from '../model/autotuneDspRequest';
import { BuildOnDeviceModelRequest } from '../model/buildOnDeviceModelRequest';
import { BuildOnDeviceModelResponse } from '../model/buildOnDeviceModelResponse';
import { BuildOrganizationOnDeviceModelRequest } from '../model/buildOrganizationOnDeviceModelRequest';
import { CalculateDataQualityMetricsRequest } from '../model/calculateDataQualityMetricsRequest';
import { CreatePreviewAIActionsJobRequest } from '../model/createPreviewAIActionsJobRequest';
import { CreateSyntheticDataRequest } from '../model/createSyntheticDataRequest';
import { DeployPretrainedModelRequest } from '../model/deployPretrainedModelRequest';
import { ExportInferenceHistoryDataRequest } from '../model/exportInferenceHistoryDataRequest';
import { ExportKerasBlockDataRequest } from '../model/exportKerasBlockDataRequest';
import { ExportOriginalDataRequest } from '../model/exportOriginalDataRequest';
import { ExportWavDataRequest } from '../model/exportWavDataRequest';
import { GenerateFeaturesRequest } from '../model/generateFeaturesRequest';
import { GenericApiResponse } from '../model/genericApiResponse';
import { GetJobResponse } from '../model/getJobResponse';
import { ImportDataFromAnotherProjectJobRequest } from '../model/importDataFromAnotherProjectJobRequest';
import { JobSummaryResponse } from '../model/jobSummaryResponse';
import { ListJobsResponse } from '../model/listJobsResponse';
import { LogStdoutResponse } from '../model/logStdoutResponse';
import { ProfileTfLiteRequest } from '../model/profileTfLiteRequest';
import { ProfileTfLiteResponse } from '../model/profileTfLiteResponse';
import { ProjectVersionRequest } from '../model/projectVersionRequest';
import { RestoreProjectFromPublicRequest } from '../model/restoreProjectFromPublicRequest';
import { RestoreProjectRequest } from '../model/restoreProjectRequest';
import { SetKerasParameterRequest } from '../model/setKerasParameterRequest';
import { SetTunerPrimaryJobRequest } from '../model/setTunerPrimaryJobRequest';
import { StartClassifyJobRequest } from '../model/startClassifyJobRequest';
import { StartJobResponse } from '../model/startJobResponse';
import { StartPerformanceCalibrationRequest } from '../model/startPerformanceCalibrationRequest';
import { StartPostProcessingRequest } from '../model/startPostProcessingRequest';
import { StartTrainingRequestAnomaly } from '../model/startTrainingRequestAnomaly';
import { UpdateJobRequest } from '../model/updateJobRequest';

import { ObjectSerializer, Authentication, VoidAuth, RequestOptionsType } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://studio.edgeimpulse.com/v1';

async function parseResponse(res: Response | UndiciResponse): Promise<any> {
    const ct = (res.headers.get('content-type') || '').toLowerCase();

    if (ct.includes('application/json')) return res.json();

    if (/^(image|video|audio)\/|application\/(octet-stream|zip|x-tar|cbor)/.test(ct)) {
        return Buffer.from(await res.arrayBuffer());
    }

    return res.text();
}

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum JobsApiApiKeys {
    ApiKeyAuthentication,
    JWTAuthentication,
    JWTHttpHeaderAuthentication,
}

type buildOnDeviceModelJobQueryParams = {
    type: string,
    impulseId?: number,
};

type buildOrganizationOnDeviceModelJobQueryParams = {
    impulseId?: number,
};

type cancelJobQueryParams = {
    forceCancel?: string,
};

type downloadJobsLogsQueryParams = {
    limit?: number,
    logLevel?: 'error' | 'warn' | 'info' | 'debug',
};

type getImpulseMigrationJobsLogsQueryParams = {
    limit?: number,
    logLevel?: 'error' | 'warn' | 'info' | 'debug',
};

type getJobsLogsQueryParams = {
    limit?: number,
    logLevel?: 'error' | 'warn' | 'info' | 'debug',
};

type getJobsSummaryQueryParams = {
    startDate: Date,
    endDate: Date,
};

type listActiveJobsQueryParams = {
    rootOnly?: boolean,
};

type listAllJobsQueryParams = {
    startDate?: Date,
    endDate?: Date,
    limit?: number,
    offset?: number,
    rootOnly?: boolean,
    key?: string,
    category?: string,
    finished?: 'successful' | 'failed' | 'all',
};

type listFinishedJobsQueryParams = {
    startDate?: Date,
    endDate?: Date,
    limit?: number,
    offset?: number,
    rootOnly?: boolean,
};

type optimizeJobQueryParams = {
    extendedFromJobId?: number,
};

type setTunerPrimaryJobQueryParams = {
    trialId: string,
};

type startClassifyJobQueryParams = {
    impulseId?: number,
};

type startDeployPretrainedModelJobQueryParams = {
    impulseId?: number,
};

type startEvaluateJobQueryParams = {
    impulseId?: number,
};

type startPerformanceCalibrationJobQueryParams = {
    impulseId?: number,
};

type startPostProcessingJobQueryParams = {
    impulseId?: number,
};

type startRetrainJobQueryParams = {
    impulseId?: number,
};


export type JobsApiOpts = {
    extraHeaders?: Record<string, string>;
};

export class JobsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : Record<string, string> = {};
    protected _opts : JobsApiOpts = { };

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuthentication': new ApiKeyAuth('header', 'x-api-key'),
        'OAuth2': new OAuth(),
        'JWTAuthentication': new ApiKeyAuth('cookie', 'jwt'),
        'JWTHttpHeaderAuthentication': new ApiKeyAuth('header', 'x-jwt-token'),
    }

    protected async handleResponse(response: Response | UndiciResponse, returnType: string | undefined): Promise<any> {
        let body = await parseResponse(response);
        if (!response.ok) {
            let errorMsg;
            if (typeof body === 'object' && body !== null && 'error' in body) {
                errorMsg = body.error;
            } else {
                errorMsg = `Failed to call "${response.url}", returned ${response.status}: ` + (typeof body === 'string' ? body : JSON.stringify(body));
            }
            throw new Error(errorMsg);
        }

        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        if (typeof body.success === 'boolean' && !body.success) {
            const errString = `Failed to call "${response.url}", returned ${response.status}: ` + body.error;
            throw new Error(body.error || errString);
        }

        return body;
    }

    constructor(basePath?: string, opts?: JobsApiOpts);
    constructor(basePathOrUsername: string, opts?: JobsApiOpts, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }

        this.opts = opts ?? { };
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set opts(opts: JobsApiOpts) {
        this._opts = opts;
    }

    get opts() {
        return this._opts;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: JobsApiApiKeys, value: string | undefined) {
        (this.authentications as any)[JobsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }


    /**
     * Autotune DSP block parameters. Updates are streamed over the websocket API.
     * @summary Autotune DSP parameters
     * @param projectId Project ID
     * @param autotuneDspRequest 
     */
    public async autotuneDspJob (projectId: number, autotuneDspRequest: AutotuneDspRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/autotune-dsp'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling autotuneDspJob.');
        }

        // verify required parameter 'autotuneDspRequest' is not null or undefined


        if (autotuneDspRequest === null || autotuneDspRequest === undefined) {
            throw new Error('Required parameter autotuneDspRequest was null or undefined when calling autotuneDspJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(autotuneDspRequest, "AutotuneDspRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Generate code to run the impulse on an embedded device. When this step is complete use `downloadHistoricDeployment` to download the artefacts. Updates are streamed over the websocket API.
     * @summary Build on-device model
     * @param projectId Project ID
     * @param type The name of the built target. You can find this by listing all deployment targets through &#x60;listDeploymentTargetsForProject&#x60; (via &#x60;GET /v1/api/{projectId}/deployment/targets&#x60;) and see the &#x60;format&#x60; type.
     * @param buildOnDeviceModelRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async buildOnDeviceModelJob (projectId: number, buildOnDeviceModelRequest: BuildOnDeviceModelRequest, queryParams: buildOnDeviceModelJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<BuildOnDeviceModelResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/build-ondevice-model'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling buildOnDeviceModelJob.');
        }

        // verify required parameter 'type' is not null or undefined

        if (queryParams.type === null || queryParams.type === undefined) {
            throw new Error('Required parameter queryParams.type was null or undefined when calling buildOnDeviceModelJob.');
        }


        // verify required parameter 'buildOnDeviceModelRequest' is not null or undefined


        if (buildOnDeviceModelRequest === null || buildOnDeviceModelRequest === undefined) {
            throw new Error('Required parameter buildOnDeviceModelRequest was null or undefined when calling buildOnDeviceModelJob.');
        }

        if (queryParams?.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(queryParams.type, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(buildOnDeviceModelRequest, "BuildOnDeviceModelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'BuildOnDeviceModelResponse'
        );
    }

    /**
     * Generate code to run the impulse on an embedded device using an organizational deployment block. When this step is complete use `downloadHistoricDeployment` to download the artefacts.  Updates are streamed over the websocket API.
     * @summary Build organizational on-device model
     * @param projectId Project ID
     * @param buildOrganizationOnDeviceModelRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async buildOrganizationOnDeviceModelJob (projectId: number, buildOrganizationOnDeviceModelRequest: BuildOrganizationOnDeviceModelRequest, queryParams?: buildOrganizationOnDeviceModelJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<BuildOnDeviceModelResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/build-ondevice-model/organization'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling buildOrganizationOnDeviceModelJob.');
        }

        // verify required parameter 'buildOrganizationOnDeviceModelRequest' is not null or undefined


        if (buildOrganizationOnDeviceModelRequest === null || buildOrganizationOnDeviceModelRequest === undefined) {
            throw new Error('Required parameter buildOrganizationOnDeviceModelRequest was null or undefined when calling buildOrganizationOnDeviceModelJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(buildOrganizationOnDeviceModelRequest, "BuildOrganizationOnDeviceModelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'BuildOnDeviceModelResponse'
        );
    }

    /**
     * Calculate data quality metrics for the dataset
     * @summary Calculate data quality metrics. Only available for EI staff.
     * @param projectId Project ID
     * @param calculateDataQualityMetricsRequest 
     */
    public async calculateDataQualityMetrics (projectId: number, calculateDataQualityMetricsRequest: CalculateDataQualityMetricsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/data-quality-metrics'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling calculateDataQualityMetrics.');
        }

        // verify required parameter 'calculateDataQualityMetricsRequest' is not null or undefined


        if (calculateDataQualityMetricsRequest === null || calculateDataQualityMetricsRequest === undefined) {
            throw new Error('Required parameter calculateDataQualityMetricsRequest was null or undefined when calling calculateDataQualityMetrics.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(calculateDataQualityMetricsRequest, "CalculateDataQualityMetricsRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Cancel a running job.
     * @summary Cancel job
     * @param projectId Project ID
     * @param jobId Job ID
     * @param forceCancel If set to \&#39;true\&#39;, we won\&#39;t wait for the job cluster to cancel the job, and will mark the job as finished.
     */
    public async cancelJob (projectId: number, jobId: number, queryParams?: cancelJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/{jobId}/cancel'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling cancelJob.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling cancelJob.');
        }

        if (queryParams?.forceCancel !== undefined) {
            localVarQueryParameters['forceCancel'] = ObjectSerializer.serialize(queryParams.forceCancel, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Run an AI Actions job over a subset of data. This will instruct the block to apply the changes directly to your dataset. To preview, use \"createPreviewAIActionsJob\". To set the config use `updateAIAction`.
     * @summary Create AI Actions job
     * @param projectId Project ID
     * @param actionId AI Action ID
     */
    public async createAIActionsJob (projectId: number, actionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/ai-actions/{actionId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'actionId' + '}', encodeURIComponent(String(actionId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createAIActionsJob.');
        }

        // verify required parameter 'actionId' is not null or undefined


        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling createAIActionsJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Do a dry-run of an AI Actions job over a subset of data. This will instruct the block to propose changes to data items (via \"setSampleProposedChanges\") rather than apply the changes directly.
     * @summary Create preview AI Actions job
     * @param projectId Project ID
     * @param actionId AI Action ID
     * @param createPreviewAIActionsJobRequest 
     */
    public async createPreviewAIActionsJob (projectId: number, actionId: number, createPreviewAIActionsJobRequest: CreatePreviewAIActionsJobRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/ai-actions/{actionId}/preview'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'actionId' + '}', encodeURIComponent(String(actionId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createPreviewAIActionsJob.');
        }

        // verify required parameter 'actionId' is not null or undefined


        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling createPreviewAIActionsJob.');
        }

        // verify required parameter 'createPreviewAIActionsJobRequest' is not null or undefined


        if (createPreviewAIActionsJobRequest === null || createPreviewAIActionsJobRequest === undefined) {
            throw new Error('Required parameter createPreviewAIActionsJobRequest was null or undefined when calling createPreviewAIActionsJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(createPreviewAIActionsJobRequest, "CreatePreviewAIActionsJobRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Generate new synthetic data
     * @summary Create synthetic data
     * @param projectId Project ID
     * @param createSyntheticDataRequest 
     */
    public async createSyntheticDataJob (projectId: number, createSyntheticDataRequest: CreateSyntheticDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/synthetic-data'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createSyntheticDataJob.');
        }

        // verify required parameter 'createSyntheticDataRequest' is not null or undefined


        if (createSyntheticDataRequest === null || createSyntheticDataRequest === undefined) {
            throw new Error('Required parameter createSyntheticDataRequest was null or undefined when calling createSyntheticDataJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(createSyntheticDataRequest, "CreateSyntheticDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Download the logs for a job (as a text file).
     * @summary Download logs
     * @param projectId Project ID
     * @param jobId Job ID
     * @param limit Maximum number of results
     * @param logLevel Log level (error, warn, info, debug)
     */
    public async downloadJobsLogs (projectId: number, jobId: number, queryParams?: downloadJobsLogsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<string> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/{jobId}/stdout/download'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling downloadJobsLogs.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling downloadJobsLogs.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.logLevel !== undefined) {
            localVarQueryParameters['logLevel'] = ObjectSerializer.serialize(queryParams.logLevel, "'error' | 'warn' | 'info' | 'debug'");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'string'
        );
    }

    /**
     * Starts a job to collate and export on-device inference history data for a given time range. Once finished, the data can be downloaded via /api/{projectId}/devices/inference-history/download-export This is experimental and may change in the future. 
     * @summary Export on-device inference history data.
     * @param projectId Project ID
     * @param exportInferenceHistoryDataRequest 
     */
    public async exportInferenceHistoryDataJob (projectId: number, exportInferenceHistoryDataRequest: ExportInferenceHistoryDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/export-inference-history'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling exportInferenceHistoryDataJob.');
        }

        // verify required parameter 'exportInferenceHistoryDataRequest' is not null or undefined


        if (exportInferenceHistoryDataRequest === null || exportInferenceHistoryDataRequest === undefined) {
            throw new Error('Required parameter exportInferenceHistoryDataRequest was null or undefined when calling exportInferenceHistoryDataJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(exportInferenceHistoryDataRequest, "ExportInferenceHistoryDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Export the training pipeline of a Keras block. Updates are streamed over the websocket API.
     * @summary Export Keras block
     * @param projectId Project ID
     * @param learnId Learn Block ID, use the impulse functions to retrieve the ID
     */
    public async exportKerasBlock (projectId: number, learnId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/train/keras/{learnId}/export'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'learnId' + '}', encodeURIComponent(String(learnId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling exportKerasBlock.');
        }

        // verify required parameter 'learnId' is not null or undefined


        if (learnId === null || learnId === undefined) {
            throw new Error('Required parameter learnId was null or undefined when calling exportKerasBlock.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Export the data of a Keras block (already split in train/validate data). Updates are streamed over the websocket API.
     * @summary Export Keras block data
     * @param projectId Project ID
     * @param learnId Learn Block ID, use the impulse functions to retrieve the ID
     * @param exportKerasBlockDataRequest 
     */
    public async exportKerasBlockData (projectId: number, learnId: number, exportKerasBlockDataRequest: ExportKerasBlockDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/train/keras/{learnId}/data'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'learnId' + '}', encodeURIComponent(String(learnId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling exportKerasBlockData.');
        }

        // verify required parameter 'learnId' is not null or undefined


        if (learnId === null || learnId === undefined) {
            throw new Error('Required parameter learnId was null or undefined when calling exportKerasBlockData.');
        }

        // verify required parameter 'exportKerasBlockDataRequest' is not null or undefined


        if (exportKerasBlockDataRequest === null || exportKerasBlockDataRequest === undefined) {
            throw new Error('Required parameter exportKerasBlockDataRequest was null or undefined when calling exportKerasBlockData.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(exportKerasBlockDataRequest, "ExportKerasBlockDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Generate features for the data explorer
     * @summary Generate data explorer features
     * @param projectId Project ID
     */
    public async generateDataExplorerFeatures (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/data-explorer-features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling generateDataExplorerFeatures.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Take the raw training set and generate features from them. Updates are streamed over the websocket API.
     * @summary Generate features
     * @param projectId Project ID
     * @param generateFeaturesRequest 
     */
    public async generateFeaturesJob (projectId: number, generateFeaturesRequest: GenerateFeaturesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/generate-features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling generateFeaturesJob.');
        }

        // verify required parameter 'generateFeaturesRequest' is not null or undefined


        if (generateFeaturesRequest === null || generateFeaturesRequest === undefined) {
            throw new Error('Required parameter generateFeaturesRequest was null or undefined when calling generateFeaturesJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(generateFeaturesRequest, "GenerateFeaturesRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Get the status for the multi-impulse migration job in this project. This is a separate route so public projects can access it. If no multi-impulse migration jobs are present, an error will be thrown.
     * @summary Get impulse migration status
     * @param projectId Project ID
     */
    public async getImpulseMigrationJobStatus (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/impulse-migration/status'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getImpulseMigrationJobStatus.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetJobResponse'
        );
    }

    /**
     * Get the logs for the multi-impulse migration job in this project. This is a separate route so public projects can access it. If no multi-impulse migration jobs are present, an error will be thrown.
     * @summary Get impulse migration logs
     * @param projectId Project ID
     * @param limit Maximum number of results
     * @param logLevel Log level (error, warn, info, debug)
     */
    public async getImpulseMigrationJobsLogs (projectId: number, queryParams?: getImpulseMigrationJobsLogsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<LogStdoutResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/impulse-migration/stdout'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getImpulseMigrationJobsLogs.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.logLevel !== undefined) {
            localVarQueryParameters['logLevel'] = ObjectSerializer.serialize(queryParams.logLevel, "'error' | 'warn' | 'info' | 'debug'");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'LogStdoutResponse'
        );
    }

    /**
     * Get the status for a job.
     * @summary Get job status
     * @param projectId Project ID
     * @param jobId Job ID
     */
    public async getJobStatus (projectId: number, jobId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/{jobId}/status'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getJobStatus.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getJobStatus.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetJobResponse'
        );
    }

    /**
     * Get the logs for a job.
     * @summary Get logs
     * @param projectId Project ID
     * @param jobId Job ID
     * @param limit Maximum number of results
     * @param logLevel Log level (error, warn, info, debug)
     */
    public async getJobsLogs (projectId: number, jobId: number, queryParams?: getJobsLogsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<LogStdoutResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/{jobId}/stdout'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getJobsLogs.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getJobsLogs.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.logLevel !== undefined) {
            localVarQueryParameters['logLevel'] = ObjectSerializer.serialize(queryParams.logLevel, "'error' | 'warn' | 'info' | 'debug'");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'LogStdoutResponse'
        );
    }

    /**
     * Get a summary of jobs, grouped by key. Used to report to users how much compute they\'ve used.
     * @summary Job summary
     * @param projectId Project ID
     * @param startDate Start date
     * @param endDate End date
     */
    public async getJobsSummary (projectId: number, queryParams: getJobsSummaryQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<JobSummaryResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/summary'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getJobsSummary.');
        }

        // verify required parameter 'startDate' is not null or undefined

        if (queryParams.startDate === null || queryParams.startDate === undefined) {
            throw new Error('Required parameter queryParams.startDate was null or undefined when calling getJobsSummary.');
        }


        // verify required parameter 'endDate' is not null or undefined

        if (queryParams.endDate === null || queryParams.endDate === undefined) {
            throw new Error('Required parameter queryParams.endDate was null or undefined when calling getJobsSummary.');
        }


        if (queryParams?.startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(queryParams.startDate, "Date");
        }

        if (queryParams?.endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(queryParams.endDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'JobSummaryResponse'
        );
    }

    /**
     * Get the results from a job started from startProfileTfliteJob (via a GET request).
     * @summary Get TFLite profile result (GET)
     * @param projectId Project ID
     * @param jobId Job ID
     */
    public async getProfileTfliteJobResult (projectId: number, jobId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ProfileTfLiteResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/profile-tflite/{jobId}/result'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProfileTfliteJobResult.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getProfileTfliteJobResult.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ProfileTfLiteResponse'
        );
    }

    /**
     * Get the results from a job started from startProfileTfliteJob (via a POST request).
     * @summary Get TFLite profile result (POST)
     * @param projectId Project ID
     * @param jobId Job ID
     */
    public async getProfileTfliteJobResultViaPostRequest (projectId: number, jobId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ProfileTfLiteResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/profile-tflite/{jobId}/result'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProfileTfliteJobResultViaPostRequest.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getProfileTfliteJobResultViaPostRequest.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ProfileTfLiteResponse'
        );
    }

    /**
     * Get all active jobs for this project
     * @summary List active jobs
     * @param projectId Project ID
     * @param rootOnly Whether to exclude jobs with a parent ID (so jobs started as part of another job)
     */
    public async listActiveJobs (projectId: number, queryParams?: listActiveJobsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListJobsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listActiveJobs.');
        }

        if (queryParams?.rootOnly !== undefined) {
            localVarQueryParameters['rootOnly'] = ObjectSerializer.serialize(queryParams.rootOnly, "boolean");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListJobsResponse'
        );
    }

    /**
     * Get all jobs for this project
     * @summary List all jobs
     * @param projectId Project ID
     * @param startDate Start date
     * @param endDate End date
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     * @param rootOnly Whether to exclude jobs with a parent ID (so jobs started as part of another job)
     * @param key Job key to filter on
     * @param category Job category to filter on
     * @param finished Job finish status to filter on
     */
    public async listAllJobs (projectId: number, queryParams?: listAllJobsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListJobsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/all'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listAllJobs.');
        }

        if (queryParams?.startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(queryParams.startDate, "Date");
        }

        if (queryParams?.endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(queryParams.endDate, "Date");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        if (queryParams?.rootOnly !== undefined) {
            localVarQueryParameters['rootOnly'] = ObjectSerializer.serialize(queryParams.rootOnly, "boolean");
        }

        if (queryParams?.key !== undefined) {
            localVarQueryParameters['key'] = ObjectSerializer.serialize(queryParams.key, "string");
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "string");
        }

        if (queryParams?.finished !== undefined) {
            localVarQueryParameters['finished'] = ObjectSerializer.serialize(queryParams.finished, "'successful' | 'failed' | 'all'");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListJobsResponse'
        );
    }

    /**
     * Get all finished jobs for this project
     * @summary List finished jobs
     * @param projectId Project ID
     * @param startDate Start date
     * @param endDate End date
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     * @param rootOnly Whether to exclude jobs with a parent ID (so jobs started as part of another job)
     */
    public async listFinishedJobs (projectId: number, queryParams?: listFinishedJobsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListJobsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/history'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listFinishedJobs.');
        }

        if (queryParams?.startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(queryParams.startDate, "Date");
        }

        if (queryParams?.endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(queryParams.endDate, "Date");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        if (queryParams?.rootOnly !== undefined) {
            localVarQueryParameters['rootOnly'] = ObjectSerializer.serialize(queryParams.rootOnly, "boolean");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListJobsResponse'
        );
    }

    /**
     * Evaluates optimal model architecture
     * @summary Optimize model
     * @param projectId Project ID
     * @param extendedFromJobId Tuner coordinator job ID for the direct descendant job to extend this search from
     */
    public async optimizeJob (projectId: number, queryParams?: optimizeJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/optimize'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling optimizeJob.');
        }

        if (queryParams?.extendedFromJobId !== undefined) {
            localVarQueryParameters['extendedFromJobId'] = ObjectSerializer.serialize(queryParams.extendedFromJobId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * If an impulse migration previously failed, use this function to retry the job.
     * @summary Retry impulse migration
     * @param projectId Project ID
     */
    public async retryImpulseMigration (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/retry-migrate-impulse'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retryImpulseMigration.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Sets EON tuner primary model
     * @summary Sets EON tuner primary model
     * @param projectId Project ID
     * @param trialId trial ID
     * @param setTunerPrimaryJobRequest 
     */
    public async setTunerPrimaryJob (projectId: number, setTunerPrimaryJobRequest: SetTunerPrimaryJobRequest, queryParams: setTunerPrimaryJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/set-tuner-primary-job'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setTunerPrimaryJob.');
        }

        // verify required parameter 'trialId' is not null or undefined

        if (queryParams.trialId === null || queryParams.trialId === undefined) {
            throw new Error('Required parameter queryParams.trialId was null or undefined when calling setTunerPrimaryJob.');
        }


        if (queryParams?.trialId !== undefined) {
            localVarQueryParameters['trialId'] = ObjectSerializer.serialize(queryParams.trialId, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setTunerPrimaryJobRequest, "SetTunerPrimaryJobRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Classifies all items in the testing dataset against the current impulse. Updates are streamed over the websocket API.
     * @summary Classify
     * @param projectId Project ID
     * @param startClassifyJobRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startClassifyJob (projectId: number, startClassifyJobRequest: StartClassifyJobRequest, queryParams?: startClassifyJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/classify'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startClassifyJob.');
        }

        // verify required parameter 'startClassifyJobRequest' is not null or undefined


        if (startClassifyJobRequest === null || startClassifyJobRequest === undefined) {
            throw new Error('Required parameter startClassifyJobRequest was null or undefined when calling startClassifyJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(startClassifyJobRequest, "StartClassifyJobRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Takes in a TFLite file and builds the model and SDK. Updates are streamed over the websocket API (or can be retrieved through the /stdout endpoint). Use getProfileTfliteJobResult to get the results when the job is completed.
     * @summary Deploy pretrained model
     * @param projectId Project ID
     * @param deployPretrainedModelRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startDeployPretrainedModelJob (projectId: number, deployPretrainedModelRequest: DeployPretrainedModelRequest, queryParams?: startDeployPretrainedModelJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/deploy-pretrained-model'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startDeployPretrainedModelJob.');
        }

        // verify required parameter 'deployPretrainedModelRequest' is not null or undefined


        if (deployPretrainedModelRequest === null || deployPretrainedModelRequest === undefined) {
            throw new Error('Required parameter deployPretrainedModelRequest was null or undefined when calling startDeployPretrainedModelJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(deployPretrainedModelRequest, "DeployPretrainedModelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Evaluates every variant of the current impulse. Updates are streamed over the websocket API.
     * @summary Evaluate
     * @param projectId Project ID
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startEvaluateJob (projectId: number, queryParams?: startEvaluateJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/evaluate'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startEvaluateJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Adds all data from an existing project into this project. This function is only available through a JWT token; and you can only add data from projects that you\'re a collaborator on.
     * @summary Import data from another project
     * @param projectId Project ID
     * @param importDataFromAnotherProjectJobRequest 
     */
    public async startImportDataFromProjectJob (projectId: number, importDataFromAnotherProjectJobRequest: ImportDataFromAnotherProjectJobRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/import-data-from-project'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startImportDataFromProjectJob.');
        }

        // verify required parameter 'importDataFromAnotherProjectJobRequest' is not null or undefined


        if (importDataFromAnotherProjectJobRequest === null || importDataFromAnotherProjectJobRequest === undefined) {
            throw new Error('Required parameter importDataFromAnotherProjectJobRequest was null or undefined when calling startImportDataFromProjectJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(importDataFromAnotherProjectJobRequest, "ImportDataFromAnotherProjectJobRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Add keywords and noise data to a project (for getting started guide)
     * @summary Add keywords and noise
     * @param projectId Project ID
     */
    public async startKeywordsNoiseJob (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/keywords-noise'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startKeywordsNoiseJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Make a version of a project public. This makes all data and state available (read-only) on a public URL, and allows users to clone this project.
     * @summary Make a version public
     * @param projectId Project ID
     * @param versionId Version ID
     */
    public async startMakeVersionPublicJob (projectId: number, versionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/versions/{versionId}/make-public'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'versionId' + '}', encodeURIComponent(String(versionId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startMakeVersionPublicJob.');
        }

        // verify required parameter 'versionId' is not null or undefined


        if (versionId === null || versionId === undefined) {
            throw new Error('Required parameter versionId was null or undefined when calling startMakeVersionPublicJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Export all the data in the project as it was uploaded to Edge Impulse.  Updates are streamed over the websocket API.
     * @summary Export original data
     * @param projectId Project ID
     * @param exportOriginalDataRequest 
     */
    public async startOriginalExportJob (projectId: number, exportOriginalDataRequest: ExportOriginalDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/export/original'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startOriginalExportJob.');
        }

        // verify required parameter 'exportOriginalDataRequest' is not null or undefined


        if (exportOriginalDataRequest === null || exportOriginalDataRequest === undefined) {
            throw new Error('Required parameter exportOriginalDataRequest was null or undefined when calling startOriginalExportJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(exportOriginalDataRequest, "ExportOriginalDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Simulates real world usage and returns performance metrics.
     * @summary Performance Calibration
     * @param projectId Project ID
     * @param startPerformanceCalibrationRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startPerformanceCalibrationJob (projectId: number, startPerformanceCalibrationRequest: StartPerformanceCalibrationRequest, queryParams?: startPerformanceCalibrationJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/performance-calibration'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startPerformanceCalibrationJob.');
        }

        // verify required parameter 'startPerformanceCalibrationRequest' is not null or undefined


        if (startPerformanceCalibrationRequest === null || startPerformanceCalibrationRequest === undefined) {
            throw new Error('Required parameter startPerformanceCalibrationRequest was null or undefined when calling startPerformanceCalibrationJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(startPerformanceCalibrationRequest, "StartPerformanceCalibrationRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Begins post processing job
     * @summary Post-processing
     * @param projectId Project ID
     * @param startPostProcessingRequest 
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startPostProcessingJob (projectId: number, startPostProcessingRequest: StartPostProcessingRequest, queryParams?: startPostProcessingJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/post-processing'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startPostProcessingJob.');
        }

        // verify required parameter 'startPostProcessingRequest' is not null or undefined


        if (startPostProcessingRequest === null || startPostProcessingRequest === undefined) {
            throw new Error('Required parameter startPostProcessingRequest was null or undefined when calling startPostProcessingJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(startPostProcessingRequest, "StartPostProcessingRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Takes in a TFLite model and returns the latency, RAM and ROM used for this model. Updates are streamed over the websocket API (or can be retrieved through the /stdout endpoint). Use getProfileTfliteJobResult to get the results when the job is completed.
     * @summary Profile TFLite model
     * @param projectId Project ID
     * @param profileTfLiteRequest 
     */
    public async startProfileTfliteJob (projectId: number, profileTfLiteRequest: ProfileTfLiteRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/profile-tflite'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startProfileTfliteJob.');
        }

        // verify required parameter 'profileTfLiteRequest' is not null or undefined


        if (profileTfLiteRequest === null || profileTfLiteRequest === undefined) {
            throw new Error('Required parameter profileTfLiteRequest was null or undefined when calling startProfileTfliteJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(profileTfLiteRequest, "ProfileTfLiteRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Restore a project to a certain version. This can only applied to a project without data, and will overwrite your impulse and all settings.
     * @summary Restore project to version
     * @param projectId Project ID
     * @param restoreProjectRequest 
     */
    public async startRestoreJob (projectId: number, restoreProjectRequest: RestoreProjectRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/restore'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startRestoreJob.');
        }

        // verify required parameter 'restoreProjectRequest' is not null or undefined


        if (restoreProjectRequest === null || restoreProjectRequest === undefined) {
            throw new Error('Required parameter restoreProjectRequest was null or undefined when calling startRestoreJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(restoreProjectRequest, "RestoreProjectRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Restore a project to a certain public version. This can only applied to a project without data, and will overwrite your impulse and all settings.
     * @summary Restore project to public version
     * @param projectId Project ID
     * @param restoreProjectFromPublicRequest 
     */
    public async startRestoreJobFromPublic (projectId: number, restoreProjectFromPublicRequest: RestoreProjectFromPublicRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/restore/from-public'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startRestoreJobFromPublic.');
        }

        // verify required parameter 'restoreProjectFromPublicRequest' is not null or undefined


        if (restoreProjectFromPublicRequest === null || restoreProjectFromPublicRequest === undefined) {
            throw new Error('Required parameter restoreProjectFromPublicRequest was null or undefined when calling startRestoreJobFromPublic.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(restoreProjectFromPublicRequest, "RestoreProjectFromPublicRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Retrains the current impulse with the last known parameters. Updates are streamed over the websocket API.
     * @summary Retrain
     * @param projectId Project ID
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async startRetrainJob (projectId: number, queryParams?: startRetrainJobQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/retrain'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startRetrainJob.');
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Create a new version of the project. This stores all data and configuration offsite. If you have access to the enterprise version of Edge Impulse you can store your data in your own storage buckets (only through JWT token authentication).
     * @summary Version project
     * @param projectId Project ID
     * @param projectVersionRequest 
     */
    public async startVersionJob (projectId: number, projectVersionRequest: ProjectVersionRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/version'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startVersionJob.');
        }

        // verify required parameter 'projectVersionRequest' is not null or undefined


        if (projectVersionRequest === null || projectVersionRequest === undefined) {
            throw new Error('Required parameter projectVersionRequest was null or undefined when calling startVersionJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(projectVersionRequest, "ProjectVersionRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Export all the data in the project in WAV format.  Updates are streamed over the websocket API.
     * @summary Export data as WAV
     * @param projectId Project ID
     * @param exportWavDataRequest 
     */
    public async startWavExportJob (projectId: number, exportWavDataRequest: ExportWavDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/export/wav'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startWavExportJob.');
        }

        // verify required parameter 'exportWavDataRequest' is not null or undefined


        if (exportWavDataRequest === null || exportWavDataRequest === undefined) {
            throw new Error('Required parameter exportWavDataRequest was null or undefined when calling startWavExportJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(exportWavDataRequest, "ExportWavDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Take the output from a DSP block and train an anomaly detection model using K-means or GMM. Updates are streamed over the websocket API.
     * @summary Train model (Anomaly)
     * @param projectId Project ID
     * @param learnId Learn Block ID, use the impulse functions to retrieve the ID
     * @param startTrainingRequestAnomaly 
     */
    public async trainAnomalyJob (projectId: number, learnId: number, startTrainingRequestAnomaly: StartTrainingRequestAnomaly, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/train/anomaly/{learnId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'learnId' + '}', encodeURIComponent(String(learnId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling trainAnomalyJob.');
        }

        // verify required parameter 'learnId' is not null or undefined


        if (learnId === null || learnId === undefined) {
            throw new Error('Required parameter learnId was null or undefined when calling trainAnomalyJob.');
        }

        // verify required parameter 'startTrainingRequestAnomaly' is not null or undefined


        if (startTrainingRequestAnomaly === null || startTrainingRequestAnomaly === undefined) {
            throw new Error('Required parameter startTrainingRequestAnomaly was null or undefined when calling trainAnomalyJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(startTrainingRequestAnomaly, "StartTrainingRequestAnomaly"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Take the output from a DSP block and train a neural network using Keras. Updates are streamed over the websocket API.
     * @summary Train model (Keras)
     * @param projectId Project ID
     * @param learnId Learn Block ID, use the impulse functions to retrieve the ID
     * @param setKerasParameterRequest 
     */
    public async trainKerasJob (projectId: number, learnId: number, setKerasParameterRequest: SetKerasParameterRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/train/keras/{learnId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'learnId' + '}', encodeURIComponent(String(learnId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling trainKerasJob.');
        }

        // verify required parameter 'learnId' is not null or undefined


        if (learnId === null || learnId === undefined) {
            throw new Error('Required parameter learnId was null or undefined when calling trainKerasJob.');
        }

        // verify required parameter 'setKerasParameterRequest' is not null or undefined


        if (setKerasParameterRequest === null || setKerasParameterRequest === undefined) {
            throw new Error('Required parameter setKerasParameterRequest was null or undefined when calling trainKerasJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setKerasParameterRequest, "SetKerasParameterRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Update a job.
     * @summary Update job
     * @param projectId Project ID
     * @param jobId Job ID
     * @param updateJobRequest 
     */
    public async updateJob (projectId: number, jobId: number, updateJobRequest: UpdateJobRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/jobs/{jobId}/update'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateJob.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling updateJob.');
        }

        // verify required parameter 'updateJobRequest' is not null or undefined


        if (updateJobRequest === null || updateJobRequest === undefined) {
            throw new Error('Required parameter updateJobRequest was null or undefined when calling updateJob.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(updateJobRequest, "UpdateJobRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }
}

/**
 * Edge Impulse API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

const PATH = require('path');
module.paths.push(PATH.join(process.cwd(), 'node_modules'));

import type { fetch as UndiciFetch, FormData as UndiciFormData, Response as UndiciResponse } from 'undici-types';

let fetch: typeof globalThis.fetch | typeof UndiciFetch;
let FormData: typeof globalThis.FormData | typeof UndiciFormData;

if (globalThis.fetch && globalThis.FormData) {
    fetch = globalThis.fetch;
    FormData = globalThis.FormData;
}
else {
    const undici = require('undici');
    fetch = undici.fetch;
    FormData = undici.FormData;
}

import { AddOrganizationBucketRequest } from '../model/addOrganizationBucketRequest';
import { CreateSignedUploadLinkRequest } from '../model/createSignedUploadLinkRequest';
import { CreateSignedUploadLinkResponse } from '../model/createSignedUploadLinkResponse';
import { DeletePortalFileRequest } from '../model/deletePortalFileRequest';
import { DownloadPortalFileRequest } from '../model/downloadPortalFileRequest';
import { DownloadPortalFileResponse } from '../model/downloadPortalFileResponse';
import { EntityCreatedResponse } from '../model/entityCreatedResponse';
import { GenericApiResponse } from '../model/genericApiResponse';
import { GetOrganizationBucketResponse } from '../model/getOrganizationBucketResponse';
import { GetOrganizationDataItemResponse } from '../model/getOrganizationDataItemResponse';
import { GetOrganizationDataItemTransformJobsResponse } from '../model/getOrganizationDataItemTransformJobsResponse';
import { GetOrganizationDatasetResponse } from '../model/getOrganizationDatasetResponse';
import { ListOrganizationBucketsResponse } from '../model/listOrganizationBucketsResponse';
import { ListOrganizationDataResponse } from '../model/listOrganizationDataResponse';
import { ListOrganizationFilesResponse } from '../model/listOrganizationFilesResponse';
import { ListPortalFilesInFolderRequest } from '../model/listPortalFilesInFolderRequest';
import { ListPortalFilesInFolderResponse } from '../model/listPortalFilesInFolderResponse';
import { OrganizationAddDataFolderRequest } from '../model/organizationAddDataFolderRequest';
import { OrganizationAddDatasetRequest } from '../model/organizationAddDatasetRequest';
import { PreviewDefaultFilesInFolderRequest } from '../model/previewDefaultFilesInFolderRequest';
import { PreviewDefaultFilesInFolderResponse } from '../model/previewDefaultFilesInFolderResponse';
import { RenamePortalFileRequest } from '../model/renamePortalFileRequest';
import { SetOrganizationDataDatasetRequest } from '../model/setOrganizationDataDatasetRequest';
import { StartJobResponse } from '../model/startJobResponse';
import { UpdateOrganizationBucketRequest } from '../model/updateOrganizationBucketRequest';
import { UpdateOrganizationDataItemRequest } from '../model/updateOrganizationDataItemRequest';
import { UpdateOrganizationDatasetRequest } from '../model/updateOrganizationDatasetRequest';
import { VerifyOrganizationBucketRequest } from '../model/verifyOrganizationBucketRequest';
import { VerifyOrganizationBucketResponse } from '../model/verifyOrganizationBucketResponse';
import { VerifyOrganizationExistingBucketRequest } from '../model/verifyOrganizationExistingBucketRequest';

import { ObjectSerializer, Authentication, VoidAuth, RequestOptionsType } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://studio.edgeimpulse.com/v1';

async function parseResponse(res: Response | UndiciResponse): Promise<any> {
    const ct = (res.headers.get('content-type') || '').toLowerCase();

    if (ct.includes('application/json')) return res.json();

    if (/^(image|video|audio)\/|application\/(octet-stream|zip|x-tar|cbor)/.test(ct)) {
        return Buffer.from(await res.arrayBuffer());
    }

    return res.text();
}

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OrganizationDataApiApiKeys {
    ApiKeyAuthentication,
    JWTAuthentication,
    JWTHttpHeaderAuthentication,
}

export type addOrganizationDataFileFormParams = {
    files: Array<RequestFile>,
};

export type addOrganizationDataItemFormParams = {
    name: string,
    bucketId?: number,
    bucketName?: string,
    dataset: string,
    bucketPath?: string,
    metadata: string,
    files: Array<RequestFile>,
};

type changeDatasetOrganizationDataItemsQueryParams = {
    dataset?: string,
    dataIds: string,
    filter?: string,
};

type clearChecklistOrganizationDataItemsQueryParams = {
    dataset?: string,
    dataIds: string,
    filter?: string,
};

type deleteOrganizationDataFileQueryParams = {
    fileName: string,
};

type deleteOrganizationDataItemsQueryParams = {
    dataset?: string,
    dataIds: string,
    filter?: string,
};

type downloadDatasetFolderQueryParams = {
    path: string,
};

type downloadOrganizationDataFileQueryParams = {
    fileName: string,
};

type downloadOrganizationDataItemQueryParams = {
    dataset?: string,
    dataIds: string,
    filter?: string,
};

type downloadOrganizationSingleDataItemQueryParams = {
    filter?: string,
};

type getOrganizationDataItemQueryParams = {
    filter?: string,
};

type getOrganizationDataItemTransformJobsQueryParams = {
    limit?: number,
    offset?: number,
};

type listOrganizationDataQueryParams = {
    dataset?: string,
    filter?: string,
    limit?: number,
    offset?: number,
};

type listOrganizationFilesQueryParams = {
    dataset?: string,
    filter?: string,
    limit?: number,
    offset?: number,
};

export type organizationBulkUpdateMetadataFormParams = {
    dataset: string,
    csvFile: RequestFile,
};

type previewOrganizationDataFileQueryParams = {
    fileName: string,
};

type refreshOrganizationDataQueryParams = {
    dataset: string,
};

type viewDatasetFileQueryParams = {
    path: string,
};


export type OrganizationDataApiOpts = {
    extraHeaders?: Record<string, string>;
};

export class OrganizationDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : Record<string, string> = {};
    protected _opts : OrganizationDataApiOpts = { };

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuthentication': new ApiKeyAuth('header', 'x-api-key'),
        'OAuth2': new OAuth(),
        'JWTAuthentication': new ApiKeyAuth('cookie', 'jwt'),
        'JWTHttpHeaderAuthentication': new ApiKeyAuth('header', 'x-jwt-token'),
    }

    protected async handleResponse(response: Response | UndiciResponse, returnType: string | undefined): Promise<any> {
        let body = await parseResponse(response);
        if (!response.ok) {
            let errorMsg;
            if (typeof body === 'object' && body !== null && 'error' in body) {
                errorMsg = body.error;
            } else {
                errorMsg = `Failed to call "${response.url}", returned ${response.status}: ` + (typeof body === 'string' ? body : JSON.stringify(body));
            }
            throw new Error(errorMsg);
        }

        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        if (typeof body.success === 'boolean' && !body.success) {
            const errString = `Failed to call "${response.url}", returned ${response.status}: ` + body.error;
            throw new Error(body.error || errString);
        }

        return body;
    }

    constructor(basePath?: string, opts?: OrganizationDataApiOpts);
    constructor(basePathOrUsername: string, opts?: OrganizationDataApiOpts, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }

        this.opts = opts ?? { };
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set opts(opts: OrganizationDataApiOpts) {
        this._opts = opts;
    }

    get opts() {
        return this._opts;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationDataApiApiKeys, value: string | undefined) {
        (this.authentications as any)[OrganizationDataApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }


    /**
     * Add a storage bucket.
     * @summary Add a storage bucket
     * @param organizationId Organization ID
     * @param addOrganizationBucketRequest 
     */
    public async addOrganizationBucket (organizationId: number, addOrganizationBucketRequest: AddOrganizationBucketRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<EntityCreatedResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling addOrganizationBucket.');
        }

        // verify required parameter 'addOrganizationBucketRequest' is not null or undefined


        if (addOrganizationBucketRequest === null || addOrganizationBucketRequest === undefined) {
            throw new Error('Required parameter addOrganizationBucketRequest was null or undefined when calling addOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(addOrganizationBucketRequest, "AddOrganizationBucketRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'EntityCreatedResponse'
        );
    }

    /**
     * Add a new file to an existing data item.
     * @summary Add files
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param files 
     */
    public async addOrganizationDataFile (organizationId: number, dataId: number, params: addOrganizationDataFileFormParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/add'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling addOrganizationDataFile.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling addOrganizationDataFile.');
        }

        // verify required parameter 'files' is not null or undefined
        if (params.files === null || params.files === undefined) {
            throw new Error('Required parameter params.files was null or undefined when calling addOrganizationDataFile.');
        }



        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        if (params.files !== undefined) {
            if (!(localVarFormParams instanceof FormData)) {
                const existingParams = localVarFormParams;
                localVarFormParams = new FormData();

                if (existingParams && typeof existingParams === 'object') {
                    for (const key of Object.keys(existingParams)) {
                        (localVarFormParams as FormData).append(key, (existingParams as Record<string, string>)[key]);
                    }
                }
            }

            const filesFiles = Array.isArray(params.files) ? params.files : [params.files];

            const Blob = globalThis.Blob || require('buffer').Blob;
            for (const f of filesFiles) {
                (localVarFormParams as FormData).append('files[]', new Blob([new Uint8Array(f.value)], {
                    type: f.options.contentType
                }), f.options.filename);
            }
        }
        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Bulk adds data items that already exist in a storage bucket. The bucket path specified should contain folders. Each folder is added as a data item in Edge Impulse.
     * @summary Add data items from bucket
     * @param organizationId Organization ID
     * @param organizationAddDataFolderRequest 
     */
    public async addOrganizationDataFolder (organizationId: number, organizationAddDataFolderRequest: OrganizationAddDataFolderRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/add-folder'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling addOrganizationDataFolder.');
        }

        // verify required parameter 'organizationAddDataFolderRequest' is not null or undefined


        if (organizationAddDataFolderRequest === null || organizationAddDataFolderRequest === undefined) {
            throw new Error('Required parameter organizationAddDataFolderRequest was null or undefined when calling addOrganizationDataFolder.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(organizationAddDataFolderRequest, "OrganizationAddDataFolderRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Add a new data item. You can add a maximum of 10000 files directly through this API. Use `addOrganizationDataFile` to add additional files.
     * @summary Add new data
     * @param organizationId Organization ID
     * @param name 
     * @param dataset 
     * @param metadata Key-value pair of metadata (in JSON format)
     * @param files 
     * @param bucketId 
     * @param bucketName Name of the bucket name (as an Edge Impulse name)
     * @param bucketPath Optional path in the bucket to create this data item (files are created under this path).
     */
    public async addOrganizationDataItem (organizationId: number, params: addOrganizationDataItemFormParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<EntityCreatedResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/add'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling addOrganizationDataItem.');
        }

        // verify required parameter 'name' is not null or undefined
        if (params.name === null || params.name === undefined) {
            throw new Error('Required parameter params.name was null or undefined when calling addOrganizationDataItem.');
        }



        // verify required parameter 'dataset' is not null or undefined
        if (params.dataset === null || params.dataset === undefined) {
            throw new Error('Required parameter params.dataset was null or undefined when calling addOrganizationDataItem.');
        }



        // verify required parameter 'metadata' is not null or undefined
        if (params.metadata === null || params.metadata === undefined) {
            throw new Error('Required parameter params.metadata was null or undefined when calling addOrganizationDataItem.');
        }



        // verify required parameter 'files' is not null or undefined
        if (params.files === null || params.files === undefined) {
            throw new Error('Required parameter params.files was null or undefined when calling addOrganizationDataItem.');
        }



        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        if (params.name !== undefined) {
            const isParametersField = ("name" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const nameSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.name as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('name', nameSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['name'] = nameSerialized;
            }
        }
        if (params.bucketId !== undefined) {
            const isParametersField = ("bucketId" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const bucketIdSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.bucketId as any, "number");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('bucketId', bucketIdSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['bucketId'] = bucketIdSerialized;
            }
        }
        if (params.bucketName !== undefined) {
            const isParametersField = ("bucketName" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const bucketNameSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.bucketName as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('bucketName', bucketNameSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['bucketName'] = bucketNameSerialized;
            }
        }
        if (params.dataset !== undefined) {
            const isParametersField = ("dataset" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const datasetSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.dataset as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('dataset', datasetSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['dataset'] = datasetSerialized;
            }
        }
        if (params.bucketPath !== undefined) {
            const isParametersField = ("bucketPath" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const bucketPathSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.bucketPath as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('bucketPath', bucketPathSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['bucketPath'] = bucketPathSerialized;
            }
        }
        if (params.metadata !== undefined) {
            const isParametersField = ("metadata" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const metadataSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.metadata as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('metadata', metadataSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['metadata'] = metadataSerialized;
            }
        }
        if (params.files !== undefined) {
            if (!(localVarFormParams instanceof FormData)) {
                const existingParams = localVarFormParams;
                localVarFormParams = new FormData();

                if (existingParams && typeof existingParams === 'object') {
                    for (const key of Object.keys(existingParams)) {
                        (localVarFormParams as FormData).append(key, (existingParams as Record<string, string>)[key]);
                    }
                }
            }

            const filesFiles = Array.isArray(params.files) ? params.files : [params.files];

            const Blob = globalThis.Blob || require('buffer').Blob;
            for (const f of filesFiles) {
                (localVarFormParams as FormData).append('files[]', new Blob([new Uint8Array(f.value)], {
                    type: f.options.contentType
                }), f.options.filename);
            }
        }
        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'EntityCreatedResponse'
        );
    }

    /**
     * Add a new research dataset
     * @summary Add dataset
     * @param organizationId Organization ID
     * @param organizationAddDatasetRequest 
     */
    public async addOrganizationDataset (organizationId: number, organizationAddDatasetRequest: OrganizationAddDatasetRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling addOrganizationDataset.');
        }

        // verify required parameter 'organizationAddDatasetRequest' is not null or undefined


        if (organizationAddDatasetRequest === null || organizationAddDatasetRequest === undefined) {
            throw new Error('Required parameter organizationAddDatasetRequest was null or undefined when calling addOrganizationDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(organizationAddDatasetRequest, "OrganizationAddDatasetRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Change the dataset for selected data items.
     * @summary Change dataset
     * @param organizationId Organization ID
     * @param dataIds Data IDs as an Array
     * @param setOrganizationDataDatasetRequest 
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async changeDatasetOrganizationDataItems (organizationId: number, setOrganizationDataDatasetRequest: SetOrganizationDataDatasetRequest, queryParams: changeDatasetOrganizationDataItemsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/change-dataset'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling changeDatasetOrganizationDataItems.');
        }

        // verify required parameter 'dataIds' is not null or undefined

        if (queryParams.dataIds === null || queryParams.dataIds === undefined) {
            throw new Error('Required parameter queryParams.dataIds was null or undefined when calling changeDatasetOrganizationDataItems.');
        }


        // verify required parameter 'setOrganizationDataDatasetRequest' is not null or undefined


        if (setOrganizationDataDatasetRequest === null || setOrganizationDataDatasetRequest === undefined) {
            throw new Error('Required parameter setOrganizationDataDatasetRequest was null or undefined when calling changeDatasetOrganizationDataItems.');
        }

        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.dataIds !== undefined) {
            localVarQueryParameters['dataIds'] = ObjectSerializer.serialize(queryParams.dataIds, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setOrganizationDataDatasetRequest, "SetOrganizationDataDatasetRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Clear all checklist flags for selected data items.
     * @summary Clear checklist for data
     * @param organizationId Organization ID
     * @param dataIds Data IDs as an Array
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async clearChecklistOrganizationDataItems (organizationId: number, queryParams: clearChecklistOrganizationDataItemsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/clear-checklist'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling clearChecklistOrganizationDataItems.');
        }

        // verify required parameter 'dataIds' is not null or undefined

        if (queryParams.dataIds === null || queryParams.dataIds === undefined) {
            throw new Error('Required parameter queryParams.dataIds was null or undefined when calling clearChecklistOrganizationDataItems.');
        }


        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.dataIds !== undefined) {
            localVarQueryParameters['dataIds'] = ObjectSerializer.serialize(queryParams.dataIds, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Creates a signed link to securely upload data to s3 bucket directly from the client.
     * @summary Create pre-signed S3 upload link
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param createSignedUploadLinkRequest 
     */
    public async createSignedUploadLinkDataset (organizationId: number, dataset: string, createSignedUploadLinkRequest: CreateSignedUploadLinkRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<CreateSignedUploadLinkResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/upload-link'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling createSignedUploadLinkDataset.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling createSignedUploadLinkDataset.');
        }

        // verify required parameter 'createSignedUploadLinkRequest' is not null or undefined


        if (createSignedUploadLinkRequest === null || createSignedUploadLinkRequest === undefined) {
            throw new Error('Required parameter createSignedUploadLinkRequest was null or undefined when calling createSignedUploadLinkDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(createSignedUploadLinkRequest, "CreateSignedUploadLinkRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'CreateSignedUploadLinkResponse'
        );
    }

    /**
     * Delete a file from a dataset
     * @summary Delete file from dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param deletePortalFileRequest 
     */
    public async deleteDatasetFile (organizationId: number, dataset: string, deletePortalFileRequest: DeletePortalFileRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/delete'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteDatasetFile.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling deleteDatasetFile.');
        }

        // verify required parameter 'deletePortalFileRequest' is not null or undefined


        if (deletePortalFileRequest === null || deletePortalFileRequest === undefined) {
            throw new Error('Required parameter deletePortalFileRequest was null or undefined when calling deleteDatasetFile.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(deletePortalFileRequest, "DeletePortalFileRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Delete a single file from a data item.
     * @summary Delete file
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param fileName File name
     */
    public async deleteOrganizationDataFile (organizationId: number, dataId: number, queryParams: deleteOrganizationDataFileQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/download'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteOrganizationDataFile.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling deleteOrganizationDataFile.');
        }

        // verify required parameter 'fileName' is not null or undefined

        if (queryParams.fileName === null || queryParams.fileName === undefined) {
            throw new Error('Required parameter queryParams.fileName was null or undefined when calling deleteOrganizationDataFile.');
        }


        if (queryParams?.fileName !== undefined) {
            localVarQueryParameters['fileName'] = ObjectSerializer.serialize(queryParams.fileName, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'DELETE',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Delete a data item. This will remove items the items from the underlying storage if your dataset has \"bucketPath\" set.
     * @summary Delete data
     * @param organizationId Organization ID
     * @param dataId Data ID
     */
    public async deleteOrganizationDataItem (organizationId: number, dataId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteOrganizationDataItem.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling deleteOrganizationDataItem.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'DELETE',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Delete all data for selected data items. This removes all data in the underlying data bucket.
     * @summary Delete data
     * @param organizationId Organization ID
     * @param dataIds Data IDs as an Array
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async deleteOrganizationDataItems (organizationId: number, queryParams: deleteOrganizationDataItemsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/delete'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteOrganizationDataItems.');
        }

        // verify required parameter 'dataIds' is not null or undefined

        if (queryParams.dataIds === null || queryParams.dataIds === undefined) {
            throw new Error('Required parameter queryParams.dataIds was null or undefined when calling deleteOrganizationDataItems.');
        }


        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.dataIds !== undefined) {
            localVarQueryParameters['dataIds'] = ObjectSerializer.serialize(queryParams.dataIds, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Download a file from a dataset. Will return a signed URL to the bucket.
     * @summary Download file from dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param downloadPortalFileRequest 
     */
    public async downloadDatasetFile (organizationId: number, dataset: string, downloadPortalFileRequest: DownloadPortalFileRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<DownloadPortalFileResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/download'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling downloadDatasetFile.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling downloadDatasetFile.');
        }

        // verify required parameter 'downloadPortalFileRequest' is not null or undefined


        if (downloadPortalFileRequest === null || downloadPortalFileRequest === undefined) {
            throw new Error('Required parameter downloadPortalFileRequest was null or undefined when calling downloadDatasetFile.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(downloadPortalFileRequest, "DownloadPortalFileRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'DownloadPortalFileResponse'
        );
    }

    /**
     * Download all files in the given folder in a dataset, ignoring any subdirectories.
     * @summary Download folder from dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param path Path, relative to dataset
     */
    public async downloadDatasetFolder (organizationId: number, dataset: string, queryParams: downloadDatasetFolderQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/download-folder'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/zip'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling downloadDatasetFolder.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling downloadDatasetFolder.');
        }

        // verify required parameter 'path' is not null or undefined

        if (queryParams.path === null || queryParams.path === undefined) {
            throw new Error('Required parameter queryParams.path was null or undefined when calling downloadDatasetFolder.');
        }


        if (queryParams?.path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(queryParams.path, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Download a single file from a data item.
     * @summary Download file
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param fileName File name
     */
    public async downloadOrganizationDataFile (organizationId: number, dataId: number, queryParams: downloadOrganizationDataFileQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/files/download'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling downloadOrganizationDataFile.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling downloadOrganizationDataFile.');
        }

        // verify required parameter 'fileName' is not null or undefined

        if (queryParams.fileName === null || queryParams.fileName === undefined) {
            throw new Error('Required parameter queryParams.fileName was null or undefined when calling downloadOrganizationDataFile.');
        }


        if (queryParams?.fileName !== undefined) {
            localVarQueryParameters['fileName'] = ObjectSerializer.serialize(queryParams.fileName, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Download all data for selected data items. This function does not query the underlying bucket.
     * @summary Download data
     * @param organizationId Organization ID
     * @param dataIds Data IDs as an Array
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async downloadOrganizationDataItem (organizationId: number, queryParams: downloadOrganizationDataItemQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/download'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/x-tar'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling downloadOrganizationDataItem.');
        }

        // verify required parameter 'dataIds' is not null or undefined

        if (queryParams.dataIds === null || queryParams.dataIds === undefined) {
            throw new Error('Required parameter queryParams.dataIds was null or undefined when calling downloadOrganizationDataItem.');
        }


        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.dataIds !== undefined) {
            localVarQueryParameters['dataIds'] = ObjectSerializer.serialize(queryParams.dataIds, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Download all data for this data item.
     * @summary Download data
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async downloadOrganizationSingleDataItem (organizationId: number, dataId: number, queryParams?: downloadOrganizationSingleDataItemQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/download'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/zip'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling downloadOrganizationSingleDataItem.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling downloadOrganizationSingleDataItem.');
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Get storage bucket details.
     * @summary Get storage bucket
     * @param organizationId Organization ID
     * @param bucketId Bucket ID
     */
    public async getOrganizationBucket (organizationId: number, bucketId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetOrganizationBucketResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets/{bucketId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'bucketId' + '}', encodeURIComponent(String(bucketId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationBucket.');
        }

        // verify required parameter 'bucketId' is not null or undefined


        if (bucketId === null || bucketId === undefined) {
            throw new Error('Required parameter bucketId was null or undefined when calling getOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetOrganizationBucketResponse'
        );
    }

    /**
     * Get a data item. This will HEAD the underlying bucket to retrieve the last file information.
     * @summary Get data metadata
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     */
    public async getOrganizationDataItem (organizationId: number, dataId: number, queryParams?: getOrganizationDataItemQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetOrganizationDataItemResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationDataItem.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling getOrganizationDataItem.');
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetOrganizationDataItemResponse'
        );
    }

    /**
     * Get all transformation jobs that ran for a data item. If limit / offset is not provided then max. 20 results are returned.
     * @summary Get transformation jobs for data item
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async getOrganizationDataItemTransformJobs (organizationId: number, dataId: number, queryParams?: getOrganizationDataItemTransformJobsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetOrganizationDataItemTransformJobsResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/transformation-jobs'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationDataItemTransformJobs.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling getOrganizationDataItemTransformJobs.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetOrganizationDataItemTransformJobsResponse'
        );
    }

    /**
     * Get information about a dataset
     * @summary Get dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     */
    public async getOrganizationDataset (organizationId: number, dataset: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetOrganizationDatasetResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationDataset.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling getOrganizationDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetOrganizationDatasetResponse'
        );
    }

    /**
     * Hide a dataset (does not remove underlying data)
     * @summary Hide dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     */
    public async hideOrganizationDataset (organizationId: number, dataset: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/hide'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling hideOrganizationDataset.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling hideOrganizationDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * List all files and directories in specified prefix.
     * @summary List files in dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param listPortalFilesInFolderRequest 
     */
    public async listDatasetFilesInFolder (organizationId: number, dataset: string, listPortalFilesInFolderRequest: ListPortalFilesInFolderRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListPortalFilesInFolderResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listDatasetFilesInFolder.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling listDatasetFilesInFolder.');
        }

        // verify required parameter 'listPortalFilesInFolderRequest' is not null or undefined


        if (listPortalFilesInFolderRequest === null || listPortalFilesInFolderRequest === undefined) {
            throw new Error('Required parameter listPortalFilesInFolderRequest was null or undefined when calling listDatasetFilesInFolder.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(listPortalFilesInFolderRequest, "ListPortalFilesInFolderRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListPortalFilesInFolderResponse'
        );
    }

    /**
     * Retrieve all configured storage buckets. This does not list the secret key.
     * @summary List storage buckets
     * @param organizationId Organization ID
     */
    public async listOrganizationBuckets (organizationId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListOrganizationBucketsResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listOrganizationBuckets.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListOrganizationBucketsResponse'
        );
    }

    /**
     * Lists all data items. This can be filtered by the ?filter parameter.
     * @summary List data
     * @param organizationId Organization ID
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async listOrganizationData (organizationId: number, queryParams?: listOrganizationDataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListOrganizationDataResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listOrganizationData.');
        }

        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListOrganizationDataResponse'
        );
    }

    /**
     * Lists all files included by the filter.
     * @summary List files
     * @param organizationId Organization ID
     * @param dataset Selected dataset
     * @param filter Data filter in SQL WHERE format, where you can reference \&#39;dataset\&#39;, \&#39;bucket\&#39;, \&#39;name\&#39;, \&#39;total_file_count\&#39;, \&#39;total_file_size\&#39;, \&#39;created\&#39; and any metadata label through \&#39;metadata-&gt;\&#39; (dots are replaced by underscore).
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async listOrganizationFiles (organizationId: number, queryParams?: listOrganizationFilesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListOrganizationFilesResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/files'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listOrganizationFiles.');
        }

        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        if (queryParams?.filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(queryParams.filter, "string");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListOrganizationFilesResponse'
        );
    }

    /**
     * Bulk update the metadata of many data items in one go. This requires you to submit a CSV file with headers, one of which the columns should be named \'name\'. The other columns are used as metadata keys.
     * @summary Bulk update metadata
     * @param organizationId Organization ID
     * @param dataset 
     * @param csvFile 
     */
    public async organizationBulkUpdateMetadata (organizationId: number, params: organizationBulkUpdateMetadataFormParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/bulk-metadata'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling organizationBulkUpdateMetadata.');
        }

        // verify required parameter 'dataset' is not null or undefined
        if (params.dataset === null || params.dataset === undefined) {
            throw new Error('Required parameter params.dataset was null or undefined when calling organizationBulkUpdateMetadata.');
        }



        // verify required parameter 'csvFile' is not null or undefined
        if (params.csvFile === null || params.csvFile === undefined) {
            throw new Error('Required parameter params.csvFile was null or undefined when calling organizationBulkUpdateMetadata.');
        }



        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        if (params.dataset !== undefined) {
            const isParametersField = ("dataset" as string) === "parameters";
            const serializableParams = isParametersField && params && ("parameters" in params);

            const datasetSerialized = serializableParams
                ? JSON.stringify((params as any).parameters)
                : ObjectSerializer.serializeFormData(params.dataset as any, "string");

            if (localVarFormParams instanceof FormData) {
                (localVarFormParams as FormData).append('dataset', datasetSerialized);
            }
            else {
                if (!localVarFormParams) {
                    localVarFormParams = {};
                }
                (localVarFormParams as Record<string, string>)['dataset'] = datasetSerialized;
            }
        }
        if (params.csvFile !== undefined) {
            if (!(localVarFormParams instanceof FormData)) {
                const existingParams = localVarFormParams;
                localVarFormParams = new FormData();

                if (existingParams && typeof existingParams === 'object') {
                    for (const key of Object.keys(existingParams)) {
                        (localVarFormParams as FormData).append(key, (existingParams as Record<string, string>)[key]);
                    }
                }
            }

            const csvFileFiles = Array.isArray(params.csvFile) ? params.csvFile : [params.csvFile];

            const Blob = globalThis.Blob || require('buffer').Blob;
            for (const f of csvFileFiles) {
                (localVarFormParams as FormData).append('csvFile', new Blob([new Uint8Array(f.value)], {
                    type: f.options.contentType
                }), f.options.filename);
            }
        }
        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Preview files and directories in a default dataset for the given prefix, with support for wildcards. This is an internal API used when starting a transformation job.
     * @summary Preview files in a default dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param previewDefaultFilesInFolderRequest 
     */
    public async previewDefaultFilesInFolder (organizationId: number, dataset: string, previewDefaultFilesInFolderRequest: PreviewDefaultFilesInFolderRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<PreviewDefaultFilesInFolderResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/preview'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling previewDefaultFilesInFolder.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling previewDefaultFilesInFolder.');
        }

        // verify required parameter 'previewDefaultFilesInFolderRequest' is not null or undefined


        if (previewDefaultFilesInFolderRequest === null || previewDefaultFilesInFolderRequest === undefined) {
            throw new Error('Required parameter previewDefaultFilesInFolderRequest was null or undefined when calling previewDefaultFilesInFolder.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(previewDefaultFilesInFolderRequest, "PreviewDefaultFilesInFolderRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'PreviewDefaultFilesInFolderResponse'
        );
    }

    /**
     * Preview a single file from a data item (same as downloadOrganizationDataFile but w/ content-disposition inline and could be truncated).
     * @summary Preview file
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param fileName File name
     */
    public async previewOrganizationDataFile (organizationId: number, dataId: number, queryParams: previewOrganizationDataFileQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}/files/preview'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling previewOrganizationDataFile.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling previewOrganizationDataFile.');
        }

        // verify required parameter 'fileName' is not null or undefined

        if (queryParams.fileName === null || queryParams.fileName === undefined) {
            throw new Error('Required parameter queryParams.fileName was null or undefined when calling previewOrganizationDataFile.');
        }


        if (queryParams?.fileName !== undefined) {
            localVarQueryParameters['fileName'] = ObjectSerializer.serialize(queryParams.fileName, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Update all data items. HEADs all underlying buckets to retrieve the last file information. Use this API after uploading data directly to S3. If your dataset has bucketId and bucketPath set then this will also remove items that have been removed from S3.
     * @summary Refresh data
     * @param organizationId Organization ID
     * @param dataset Selected dataset
     */
    public async refreshOrganizationData (organizationId: number, queryParams: refreshOrganizationDataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<StartJobResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/refresh'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling refreshOrganizationData.');
        }

        // verify required parameter 'dataset' is not null or undefined

        if (queryParams.dataset === null || queryParams.dataset === undefined) {
            throw new Error('Required parameter queryParams.dataset was null or undefined when calling refreshOrganizationData.');
        }


        if (queryParams?.dataset !== undefined) {
            localVarQueryParameters['dataset'] = ObjectSerializer.serialize(queryParams.dataset, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'StartJobResponse'
        );
    }

    /**
     * Remove a storage bucket and associated datasets. This will render any data in this storage bucket unreachable.
     * @summary Remove storage bucket
     * @param organizationId Organization ID
     * @param bucketId Bucket ID
     */
    public async removeOrganizationBucket (organizationId: number, bucketId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets/{bucketId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'bucketId' + '}', encodeURIComponent(String(bucketId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling removeOrganizationBucket.');
        }

        // verify required parameter 'bucketId' is not null or undefined


        if (bucketId === null || bucketId === undefined) {
            throw new Error('Required parameter bucketId was null or undefined when calling removeOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'DELETE',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Rename a file in a dataset
     * @summary Rename file from dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param renamePortalFileRequest 
     */
    public async renameDatasetFile (organizationId: number, dataset: string, renamePortalFileRequest: RenamePortalFileRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/rename'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling renameDatasetFile.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling renameDatasetFile.');
        }

        // verify required parameter 'renamePortalFileRequest' is not null or undefined


        if (renamePortalFileRequest === null || renamePortalFileRequest === undefined) {
            throw new Error('Required parameter renamePortalFileRequest was null or undefined when calling renameDatasetFile.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(renamePortalFileRequest, "RenamePortalFileRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Updates storage bucket details. This only updates fields that were set in the request body. Before updating the bucket details, it is required to verify the connection using the POST /api/organizations/{organizationId}/buckets/verify endpoint.  The verification process: 1. Call the verify endpoint with the new bucket details. 2. Poll the verify endpoint until it responds with `connectionStatus: connected`. 3. If the endpoint responds with `connectionStatus: error`, the verification has failed.  Only proceed with updating the bucket details after receiving a `connected` status. The polling interval and timeout should be determined based on your application\'s requirements. 
     * @summary Update storage bucket
     * @param organizationId Organization ID
     * @param bucketId Bucket ID
     * @param updateOrganizationBucketRequest 
     */
    public async updateOrganizationBucket (organizationId: number, bucketId: number, updateOrganizationBucketRequest: UpdateOrganizationBucketRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets/{bucketId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'bucketId' + '}', encodeURIComponent(String(bucketId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling updateOrganizationBucket.');
        }

        // verify required parameter 'bucketId' is not null or undefined


        if (bucketId === null || bucketId === undefined) {
            throw new Error('Required parameter bucketId was null or undefined when calling updateOrganizationBucket.');
        }

        // verify required parameter 'updateOrganizationBucketRequest' is not null or undefined


        if (updateOrganizationBucketRequest === null || updateOrganizationBucketRequest === undefined) {
            throw new Error('Required parameter updateOrganizationBucketRequest was null or undefined when calling updateOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(updateOrganizationBucketRequest, "UpdateOrganizationBucketRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Update the data item metadata.
     * @summary Update data metadata
     * @param organizationId Organization ID
     * @param dataId Data ID
     * @param updateOrganizationDataItemRequest 
     */
    public async updateOrganizationDataItem (organizationId: number, dataId: number, updateOrganizationDataItemRequest: UpdateOrganizationDataItemRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/data/{dataId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataId' + '}', encodeURIComponent(String(dataId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling updateOrganizationDataItem.');
        }

        // verify required parameter 'dataId' is not null or undefined


        if (dataId === null || dataId === undefined) {
            throw new Error('Required parameter dataId was null or undefined when calling updateOrganizationDataItem.');
        }

        // verify required parameter 'updateOrganizationDataItemRequest' is not null or undefined


        if (updateOrganizationDataItemRequest === null || updateOrganizationDataItemRequest === undefined) {
            throw new Error('Required parameter updateOrganizationDataItemRequest was null or undefined when calling updateOrganizationDataItem.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(updateOrganizationDataItemRequest, "UpdateOrganizationDataItemRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Set information about a dataset
     * @summary Update dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param updateOrganizationDatasetRequest 
     */
    public async updateOrganizationDataset (organizationId: number, dataset: string, updateOrganizationDatasetRequest: UpdateOrganizationDatasetRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling updateOrganizationDataset.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling updateOrganizationDataset.');
        }

        // verify required parameter 'updateOrganizationDatasetRequest' is not null or undefined


        if (updateOrganizationDatasetRequest === null || updateOrganizationDatasetRequest === undefined) {
            throw new Error('Required parameter updateOrganizationDatasetRequest was null or undefined when calling updateOrganizationDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(updateOrganizationDatasetRequest, "UpdateOrganizationDatasetRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Verify whether we can reach a dataset (and return some random files, used for data sources)
     * @summary Verify dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     */
    public async verifyDataset (organizationId: number, dataset: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<VerifyOrganizationBucketResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/verify'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling verifyDataset.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling verifyDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'VerifyOrganizationBucketResponse'
        );
    }

    /**
     * Verify whether we can reach a bucket before adding it.
     * @summary Verify existing bucket connectivity
     * @param organizationId Organization ID
     * @param bucketId Bucket ID
     * @param verifyOrganizationExistingBucketRequest 
     */
    public async verifyExistingOrganizationBucket (organizationId: number, bucketId: number, verifyOrganizationExistingBucketRequest: VerifyOrganizationExistingBucketRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<VerifyOrganizationBucketResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets/{bucketId}/verify'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'bucketId' + '}', encodeURIComponent(String(bucketId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling verifyExistingOrganizationBucket.');
        }

        // verify required parameter 'bucketId' is not null or undefined


        if (bucketId === null || bucketId === undefined) {
            throw new Error('Required parameter bucketId was null or undefined when calling verifyExistingOrganizationBucket.');
        }

        // verify required parameter 'verifyOrganizationExistingBucketRequest' is not null or undefined


        if (verifyOrganizationExistingBucketRequest === null || verifyOrganizationExistingBucketRequest === undefined) {
            throw new Error('Required parameter verifyOrganizationExistingBucketRequest was null or undefined when calling verifyExistingOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(verifyOrganizationExistingBucketRequest, "VerifyOrganizationExistingBucketRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'VerifyOrganizationBucketResponse'
        );
    }

    /**
     * Verify connectivity to a storage bucket and optionally list its contents. This endpoint allows you to: 1. Check if the provided bucket credentials are valid and the bucket is accessible. 2. Optionally list files in the bucket up to a specified limit. 3. Validate the bucket configuration before adding it to the organization.  The request can include details such as the bucket name, region, credentials, and listing options. The response provides information about the bucket\'s accessibility and, if requested, a list of files in the bucket.  Important note on verification process: - For S3-compatible storage backends: Verification is expected to be immediate. - For Azure buckets: Verification takes longer. Users are required to poll this endpoint until the connectionStatus changes from \'connecting\' to \'connected\'.  When dealing with Azure buckets, implement a polling mechanism to check the status periodically until it\'s confirmed as connected. 
     * @summary Verify bucket connectivity
     * @param organizationId Organization ID
     * @param verifyOrganizationBucketRequest 
     */
    public async verifyOrganizationBucket (organizationId: number, verifyOrganizationBucketRequest: VerifyOrganizationBucketRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<VerifyOrganizationBucketResponse> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/buckets/verify'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling verifyOrganizationBucket.');
        }

        // verify required parameter 'verifyOrganizationBucketRequest' is not null or undefined


        if (verifyOrganizationBucketRequest === null || verifyOrganizationBucketRequest === undefined) {
            throw new Error('Required parameter verifyOrganizationBucketRequest was null or undefined when calling verifyOrganizationBucket.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(verifyOrganizationBucketRequest, "VerifyOrganizationBucketRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'VerifyOrganizationBucketResponse'
        );
    }

    /**
     * View a file that\'s located in a dataset (requires JWT auth). File might be converted (e.g. Parquet) or truncated (e.g. CSV).
     * @summary View file from dataset
     * @param organizationId Organization ID
     * @param dataset Dataset name
     * @param path Path to file in portal
     */
    public async viewDatasetFile (organizationId: number, dataset: string, queryParams: viewDatasetFileQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/organizations/{organizationId}/dataset/{dataset}/files/view'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'dataset' + '}', encodeURIComponent(String(dataset)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'organizationId' is not null or undefined


        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling viewDatasetFile.');
        }

        // verify required parameter 'dataset' is not null or undefined


        if (dataset === null || dataset === undefined) {
            throw new Error('Required parameter dataset was null or undefined when calling viewDatasetFile.');
        }

        // verify required parameter 'path' is not null or undefined

        if (queryParams.path === null || queryParams.path === undefined) {
            throw new Error('Required parameter queryParams.path was null or undefined when calling viewDatasetFile.');
        }


        if (queryParams?.path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(queryParams.path, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }
}

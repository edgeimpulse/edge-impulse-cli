/**
 * Edge Impulse API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// tslint:disable-next-line: variable-name, no-var-requires
const PATH = require('path');
// tslint:disable-next-line: no-unsafe-any
module.paths.push(PATH.join(process.cwd(), 'node_modules'));

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { BatchAddMetadataRequest } from '../model/batchAddMetadataRequest';
import { BatchClearMetadataByKeyRequest } from '../model/batchClearMetadataByKeyRequest';
import { BatchEditBoundingBoxesRequest } from '../model/batchEditBoundingBoxesRequest';
import { CountSamplesResponse } from '../model/countSamplesResponse';
import { CropSampleRequest } from '../model/cropSampleRequest';
import { CropSampleResponse } from '../model/cropSampleResponse';
import { DataExplorerPredictionsResponse } from '../model/dataExplorerPredictionsResponse';
import { DataExplorerSettings } from '../model/dataExplorerSettings';
import { EditSampleLabelRequest } from '../model/editSampleLabelRequest';
import { FindSegmentSampleRequest } from '../model/findSegmentSampleRequest';
import { FindSegmentSampleResponse } from '../model/findSegmentSampleResponse';
import { GenericApiResponse } from '../model/genericApiResponse';
import { StartJobResponse } from '../model/startJobResponse';
import { GetAIActionsProposedChangesResponse } from '../model/getAIActionsProposedChangesResponse';
import { GetAllImportedFromResponse } from '../model/getAllImportedFromResponse';
import { GetDataExplorerFeaturesResponse } from '../model/getDataExplorerFeaturesResponse';
import { GetDataExplorerSettingsResponse } from '../model/getDataExplorerSettingsResponse';
import { GetDatasetRatioResponse } from '../model/getDatasetRatioResponse';
import { GetDiversityDataResponse } from '../model/getDiversityDataResponse';
import { GetLabelNoiseDataResponse } from '../model/getLabelNoiseDataResponse';
import { GetSampleMetadataFilterOptionsResponse } from '../model/getSampleMetadataFilterOptionsResponse';
import { GetSampleMetadataResponse } from '../model/getSampleMetadataResponse';
import { GetSampleResponse } from '../model/getSampleResponse';
import { HasDataExplorerFeaturesResponse } from '../model/hasDataExplorerFeaturesResponse';
import { ListSamplesResponse } from '../model/listSamplesResponse';
import { MoveRawDataRequest } from '../model/moveRawDataRequest';
import { ObjectDetectionAutoLabelRequest } from '../model/objectDetectionAutoLabelRequest';
import { ObjectDetectionAutoLabelResponse } from '../model/objectDetectionAutoLabelResponse';
import { ObjectDetectionLabelQueueCountResponse } from '../model/objectDetectionLabelQueueCountResponse';
import { ObjectDetectionLabelQueueResponse } from '../model/objectDetectionLabelQueueResponse';
import { RawDataCategory } from '../model/rawDataCategory';
import { RebalanceDatasetResponse } from '../model/rebalanceDatasetResponse';
import { RenameSampleRequest } from '../model/renameSampleRequest';
import { SampleBoundingBoxesRequest } from '../model/sampleBoundingBoxesRequest';
import { SegmentSampleRequest } from '../model/segmentSampleRequest';
import { SetSampleMetadataRequest } from '../model/setSampleMetadataRequest';
import { SetSampleProposedChangesRequest } from '../model/setSampleProposedChangesRequest';
import { SetSampleStructuredLabelsRequest } from '../model/setSampleStructuredLabelsRequest';
import { SetSampleVideoDimensionsRequest } from '../model/setSampleVideoDimensionsRequest';
import { SplitSampleInFramesRequest } from '../model/splitSampleInFramesRequest';
import { StoreSegmentLengthRequest } from '../model/storeSegmentLengthRequest';
import { TrackObjectsRequest } from '../model/trackObjectsRequest';
import { TrackObjectsResponse } from '../model/trackObjectsResponse';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://studio.edgeimpulse.com/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RawDataApiApiKeys {
    ApiKeyAuthentication,
    JWTAuthentication,
    JWTHttpHeaderAuthentication,
}

type batchAddMetadataQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchClearMetadataQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchClearMetadataByKeyQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchDeleteQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchDisableQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEditBoundingBoxesQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEditLabelsQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEnableQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchMoveQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type countSamplesQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type getAllImportedFromQueryParams = {
    limit?: number,
    offset?: number,
};

type getSampleQueryParams = {
    limitPayloadValues?: number,
    cacheKey?: string,
    impulseId?: number,
    proposedActionsJobId?: number,
    truncateStructuredLabels?: boolean,
};

type getSampleAsAudioQueryParams = {
    axisIx: number,
    sliceStart?: number,
    sliceEnd?: number,
    cacheKey?: string,
};

type getSampleAsImageQueryParams = {
    afterInputBlock?: boolean,
    cacheKey?: string,
    impulseId?: number,
};

type getSampleAsVideoQueryParams = {
    afterInputBlock?: boolean,
    cacheKey?: string,
    impulseId?: number,
};

type getSampleMetadataQueryParams = {
    category: RawDataCategory,
};

type getSampleMetadataFilterOptionsQueryParams = {
    category: RawDataCategory,
    limit?: number,
    offset?: number,
};

type getSampleSliceQueryParams = {
    sliceStart: number,
    sliceEnd?: number,
    impulseId?: number,
    truncateStructuredLabels?: boolean,
};

type getUncroppedDownsampledSampleQueryParams = {
    limitPayloadValues?: number,
    zoomStart?: number,
    zoomEnd?: number,
    impulseId?: number,
    truncateStructuredLabels?: boolean,
};

type listSamplesQueryParams = {
    category: RawDataCategory,
    limit?: number,
    offset?: number,
    excludeSensors?: boolean,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    proposedActionsJobId?: number,
    truncateStructuredLabels?: boolean,
    sortBy?: 'id-desc' | 'random',
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

export type uploadDataExplorerScreenshotFormParams = {
    image: RequestFile,
};


export type RawDataApiOpts = {
    extraHeaders?: {
        [name: string]: string
    },
};

export class RawDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _opts : RawDataApiOpts = { };

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuthentication': new ApiKeyAuth('header', 'x-api-key'),
        'OAuth2': new OAuth(),
        'JWTAuthentication': new ApiKeyAuth('cookie', 'jwt'),
        'JWTHttpHeaderAuthentication': new ApiKeyAuth('header', 'x-jwt-token'),
    }

    constructor(basePath?: string, opts?: RawDataApiOpts);
    constructor(basePathOrUsername: string, opts?: RawDataApiOpts, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }

        this.opts = opts ?? { };
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set opts(opts: RawDataApiOpts) {
        this._opts = opts;
    }

    get opts() {
        return this._opts;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RawDataApiApiKeys, value: string | undefined) {
        (this.authentications as any)[RawDataApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }


    /**
     * Add specific metadata for multiple samples.
     * @summary Add metadata (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchAddMetadataRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchAddMetadata (projectId: number, batchAddMetadataRequest: BatchAddMetadataRequest, queryParams: batchAddMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/add-metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchAddMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchAddMetadata.');
        }


        // verify required parameter 'batchAddMetadataRequest' is not null or undefined


        if (batchAddMetadataRequest === null || batchAddMetadataRequest === undefined) {
            throw new Error('Required parameter batchAddMetadataRequest was null or undefined when calling batchAddMetadata.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(batchAddMetadataRequest, "BatchAddMetadataRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Clears all metadata for multiple samples.
     * @summary Clear all metadata (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchClearMetadata (projectId: number, queryParams: batchClearMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/clear-metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchClearMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchClearMetadata.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Clears a specific metadata field (by key) for multiple samples.
     * @summary Clear metadata by key (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchClearMetadataByKeyRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchClearMetadataByKey (projectId: number, batchClearMetadataByKeyRequest: BatchClearMetadataByKeyRequest, queryParams: batchClearMetadataByKeyQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/clear-metadata-by-key'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchClearMetadataByKey.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchClearMetadataByKey.');
        }


        // verify required parameter 'batchClearMetadataByKeyRequest' is not null or undefined


        if (batchClearMetadataByKeyRequest === null || batchClearMetadataByKeyRequest === undefined) {
            throw new Error('Required parameter batchClearMetadataByKeyRequest was null or undefined when calling batchClearMetadataByKey.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(batchClearMetadataByKeyRequest, "BatchClearMetadataByKeyRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Deletes samples. Note that this does not delete the data from cold storage. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Remove multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchDelete (projectId: number, queryParams: batchDeleteQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/delete'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchDelete.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchDelete.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Disables samples, ensuring that they are excluded from the dataset. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Disable multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchDisable (projectId: number, queryParams: batchDisableQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/disable-samples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchDisable.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchDisable.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Relabels (or removes) bounding boxes for multiple samples. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Edit bounding boxes for multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchEditBoundingBoxesRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEditBoundingBoxes (projectId: number, batchEditBoundingBoxesRequest: BatchEditBoundingBoxesRequest, queryParams: batchEditBoundingBoxesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/edit-bounding-boxes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEditBoundingBoxes.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEditBoundingBoxes.');
        }


        // verify required parameter 'batchEditBoundingBoxesRequest' is not null or undefined


        if (batchEditBoundingBoxesRequest === null || batchEditBoundingBoxesRequest === undefined) {
            throw new Error('Required parameter batchEditBoundingBoxesRequest was null or undefined when calling batchEditBoundingBoxes.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(batchEditBoundingBoxesRequest, "BatchEditBoundingBoxesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Sets the label (also known as class) of multiple samples. If you want to relabel bounding boxes, use \"batchEditBoundingBoxes\" instead. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Edit labels for multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param editSampleLabelRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEditLabels (projectId: number, editSampleLabelRequest: EditSampleLabelRequest, queryParams: batchEditLabelsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/edit-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEditLabels.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEditLabels.');
        }


        // verify required parameter 'editSampleLabelRequest' is not null or undefined


        if (editSampleLabelRequest === null || editSampleLabelRequest === undefined) {
            throw new Error('Required parameter editSampleLabelRequest was null or undefined when calling batchEditLabels.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(editSampleLabelRequest, "EditSampleLabelRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Enables samples, ensuring that they are not excluded from the dataset. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Enable multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEnable (projectId: number, queryParams: batchEnableQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/enable-samples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEnable.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEnable.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Move multiple samples to another category (e.g. from test to training). Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Move multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param moveRawDataRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchMove (projectId: number, moveRawDataRequest: MoveRawDataRequest, queryParams: batchMoveQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/moveSamples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchMove.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchMove.');
        }


        // verify required parameter 'moveRawDataRequest' is not null or undefined


        if (moveRawDataRequest === null || moveRawDataRequest === undefined) {
            throw new Error('Required parameter moveRawDataRequest was null or undefined when calling batchMove.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(moveRawDataRequest, "MoveRawDataRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Classify an image using another neural network.
     * @summary Auto-label an image
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param objectDetectionAutoLabelRequest 
     */
    public async classifyUsingAutolabel (projectId: number, sampleId: number, objectDetectionAutoLabelRequest: ObjectDetectionAutoLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionAutoLabelResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/autolabel'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling classifyUsingAutolabel.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling classifyUsingAutolabel.');
        }

        // verify required parameter 'objectDetectionAutoLabelRequest' is not null or undefined


        if (objectDetectionAutoLabelRequest === null || objectDetectionAutoLabelRequest === undefined) {
            throw new Error('Required parameter objectDetectionAutoLabelRequest was null or undefined when calling classifyUsingAutolabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(objectDetectionAutoLabelRequest, "ObjectDetectionAutoLabelRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<ObjectDetectionAutoLabelResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObjectDetectionAutoLabelResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Clears all object detection labels for this dataset, and places all images back in the labeling queue.
     * @summary Clear all object detection labels
     * @param projectId Project ID
     */
    public async clearAllObjectDetectionLabels (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/clear-all-object-detection-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling clearAllObjectDetectionLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Remove the current data explorer state
     * @summary Clear data explorer
     * @param projectId Project ID
     */
    public async clearDataExplorer (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/clear'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling clearDataExplorer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Count all raw data by category.
     * @summary Count samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async countSamples (projectId: number, queryParams: countSamplesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<CountSamplesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/count'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling countSamples.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling countSamples.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<CountSamplesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CountSamplesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Crop a sample to within a new range.
     * @summary Crop sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param cropSampleRequest 
     */
    public async cropSample (projectId: number, sampleId: number, cropSampleRequest: CropSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<CropSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/crop'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling cropSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling cropSample.');
        }

        // verify required parameter 'cropSampleRequest' is not null or undefined


        if (cropSampleRequest === null || cropSampleRequest === undefined) {
            throw new Error('Required parameter cropSampleRequest was null or undefined when calling cropSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(cropSampleRequest, "CropSampleRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<CropSampleResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CropSampleResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Deletes all samples for this project over all categories. This also invalidates all DSP and learn blocks. Note that this does not delete the data from cold storage.
     * @summary Remove all samples
     * @param projectId Project ID
     */
    public async deleteAllSamples (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/delete-all'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteAllSamples.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Deletes all samples for this project over a single category. Note that this does not delete the data from cold storage.
     * @summary Remove all samples by category
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to download data from
     */
    public async deleteAllSamplesByCategory (projectId: number, category: RawDataCategory, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/delete-all/{category}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteAllSamplesByCategory.');
        }

        // verify required parameter 'category' is not null or undefined


        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling deleteAllSamplesByCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Deletes the sample. Note that this does not delete the data from cold storage.
     * @summary Remove sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async deleteSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling deleteSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Disable a sample, ensuring that it is excluded from the dataset.
     * @summary Disable sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async disableSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/disable'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling disableSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling disableSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Sets the label (also known as class) of the sample. Use the same label for similar types of data, as they are used during training.
     * @summary Edit label
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param editSampleLabelRequest 
     */
    public async editLabel (projectId: number, sampleId: number, editSampleLabelRequest: EditSampleLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/edit-label'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling editLabel.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling editLabel.');
        }

        // verify required parameter 'editSampleLabelRequest' is not null or undefined


        if (editSampleLabelRequest === null || editSampleLabelRequest === undefined) {
            throw new Error('Required parameter editSampleLabelRequest was null or undefined when calling editLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(editSampleLabelRequest, "EditSampleLabelRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Enable a sample, ensuring that it is not excluded from the dataset.
     * @summary Enable sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async enableSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/enable'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling enableSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling enableSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Find start and end times for all non-noise events in a sample
     * @summary Find segments
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param findSegmentSampleRequest 
     */
    public async findSegmentsInSample (projectId: number, sampleId: number, findSegmentSampleRequest: FindSegmentSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<FindSegmentSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/find-segments'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findSegmentsInSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling findSegmentsInSample.');
        }

        // verify required parameter 'findSegmentSampleRequest' is not null or undefined


        if (findSegmentSampleRequest === null || findSegmentSampleRequest === undefined) {
            throw new Error('Required parameter findSegmentSampleRequest was null or undefined when calling findSegmentsInSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(findSegmentSampleRequest, "FindSegmentSampleRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<FindSegmentSampleResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "FindSegmentSampleResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get proposed changes from an AI Actions job.
     * @summary Get AI Actions proposed changes
     * @param projectId Project ID
     * @param jobId Job ID
     */
    public async getAIActionsProposedChanges (projectId: number, jobId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetAIActionsProposedChangesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/ai-actions-preview/{jobId}/proposed-changes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAIActionsProposedChanges.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getAIActionsProposedChanges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetAIActionsProposedChangesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetAIActionsProposedChangesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Lists all data with an \'imported from\' metadata key. Used to check in a data source which items are already in a project.
     * @summary List data with \"imported from\" metadata key
     * @param projectId Project ID
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async getAllImportedFrom (projectId: number, queryParams?: getAllImportedFromQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetAllImportedFromResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/imported-from'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAllImportedFrom.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetAllImportedFromResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetAllImportedFromResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * t-SNE2 output of the raw dataset
     * @summary Get data explorer features
     * @param projectId Project ID
     */
    public async getDataExplorerFeatures (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetDataExplorerFeaturesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetDataExplorerFeaturesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Predictions for every data explorer point (only available when using current impulse to populate data explorer)
     * @summary Get data explorer predictions
     * @param projectId Project ID
     */
    public async getDataExplorerPredictions (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<DataExplorerPredictionsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/predictions'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerPredictions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<DataExplorerPredictionsResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DataExplorerPredictionsResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get data explorer configuration, like the type of data, and the input / dsp block to use.
     * @summary Get data explorer settings
     * @param projectId Project ID
     */
    public async getDataExplorerSettings (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDataExplorerSettingsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/settings'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetDataExplorerSettingsResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetDataExplorerSettingsResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Retrieve number of samples in train and test set.
     * @summary Get dataset ratio
     * @param projectId Project ID
     */
    public async getDatasetRatio (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDatasetRatioResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/ratio'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDatasetRatio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetDatasetRatioResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetDatasetRatioResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Obtain metrics that describe the similarity and diversity of a dataset. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Get diversity metrics data
     * @param projectId Project ID
     */
    public async getDiversityData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDiversityDataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/diversity'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDiversityData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetDiversityDataResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetDiversityDataResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Obtain metrics that describe potential label noise issues in the dataset. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Get label noise data
     * @param projectId Project ID
     */
    public async getLabelNoiseData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetLabelNoiseDataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/label-noise'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getLabelNoiseData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetLabelNoiseDataResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetLabelNoiseDataResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get all unlabeled items from the object detection queue.
     * @summary Object detection label queue
     * @param projectId Project ID
     */
    public async getObjectDetectionLabelQueue (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionLabelQueueResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/label-object-detection-queue'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getObjectDetectionLabelQueue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<ObjectDetectionLabelQueueResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObjectDetectionLabelQueueResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get count for unlabeled items from the object detection queue.
     * @summary Object detection label queue count
     * @param projectId Project ID
     */
    public async getObjectDetectionLabelQueueCount (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionLabelQueueCountResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/label-object-detection-queue/count'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getObjectDetectionLabelQueueCount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<ObjectDetectionLabelQueueCountResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObjectDetectionLabelQueueCountResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a sample.
     * @summary Get sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param limitPayloadValues Limit the number of payload values in the response
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param proposedActionsJobId Pass this parameter when querying samples from inside an AI Action job. If you pass this parameter in a multi-stage AI Action, previous proposed changes (from an earlier step) will be applied to the returned dataset.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getSample (projectId: number, sampleId: number, queryParams?: getSampleQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSample.');
        }

        if (queryParams?.limitPayloadValues !== undefined) {
            localVarQueryParameters['limitPayloadValues'] = ObjectSerializer.serialize(queryParams.limitPayloadValues, "number");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.proposedActionsJobId !== undefined) {
            localVarQueryParameters['proposedActionsJobId'] = ObjectSerializer.serialize(queryParams.proposedActionsJobId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetSampleResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetSampleResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a sample as a WAV file. This only applies to samples with an audio axis.
     * @summary Get WAV file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param axisIx Axis index
     * @param sliceStart Begin index of the slice. If not given, the whole sample is used.
     * @param sliceEnd End index of the slice. If not given, the whole sample is used.
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     */
    public async getSampleAsAudio (projectId: number, sampleId: number, queryParams: getSampleAsAudioQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/wav'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['audio/wav'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsAudio.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsAudio.');
        }

        // verify required parameter 'axisIx' is not null or undefined

        if (queryParams.axisIx === null || queryParams.axisIx === undefined) {
            throw new Error('Required parameter queryParams.axisIx was null or undefined when calling getSampleAsAudio.');
        }


        if (queryParams?.axisIx !== undefined) {
            localVarQueryParameters['axisIx'] = ObjectSerializer.serialize(queryParams.axisIx, "number");
        }

        if (queryParams?.sliceStart !== undefined) {
            localVarQueryParameters['sliceStart'] = ObjectSerializer.serialize(queryParams.sliceStart, "number");
        }

        if (queryParams?.sliceEnd !== undefined) {
            localVarQueryParameters['sliceEnd'] = ObjectSerializer.serialize(queryParams.sliceEnd, "number");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a sample as an image file. This only applies to samples with RGBA data.
     * @summary Get image file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param afterInputBlock Whether to process the image through the input block first
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async getSampleAsImage (projectId: number, sampleId: number, queryParams?: getSampleAsImageQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/image'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['image/jpeg'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsImage.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsImage.');
        }

        if (queryParams?.afterInputBlock !== undefined) {
            localVarQueryParameters['afterInputBlock'] = ObjectSerializer.serialize(queryParams.afterInputBlock, "boolean");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Download a sample in it\'s original format as uploaded to the ingestion service.
     * @summary Download file
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async getSampleAsRaw (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/raw'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsRaw.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsRaw.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a sample as an video file. This only applies to samples with video data.
     * @summary Get video file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param afterInputBlock Whether to process the image through the input block first
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async getSampleAsVideo (projectId: number, sampleId: number, queryParams?: getSampleAsVideoQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/video'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['video/mp4'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsVideo.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsVideo.');
        }

        if (queryParams?.afterInputBlock !== undefined) {
            localVarQueryParameters['afterInputBlock'] = ObjectSerializer.serialize(queryParams.afterInputBlock, "boolean");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get metadata for all samples in a project.
     * @summary Get project sample metadata
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     */
    public async getSampleMetadata (projectId: number, queryParams: getSampleMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleMetadataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling getSampleMetadata.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetSampleMetadataResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetSampleMetadataResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a list of unique key value pairs across all samples in a project that can be applied as filters to the /api/{projectId}/raw-data endpoint
     * @summary Get project sample metadata filter options
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async getSampleMetadataFilterOptions (projectId: number, queryParams: getSampleMetadataFilterOptionsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleMetadataFilterOptionsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/metadata-filter-options'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleMetadataFilterOptions.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling getSampleMetadataFilterOptions.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetSampleMetadataFilterOptionsResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetSampleMetadataFilterOptionsResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get a slice of a sample.
     * @summary Get sample slice
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param sliceStart Begin index of the slice
     * @param sliceEnd End index of the slice. If not given, the sample will be sliced to the same length as the impulse input block window length.
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getSampleSlice (projectId: number, sampleId: number, queryParams: getSampleSliceQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/slice'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleSlice.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleSlice.');
        }

        // verify required parameter 'sliceStart' is not null or undefined

        if (queryParams.sliceStart === null || queryParams.sliceStart === undefined) {
            throw new Error('Required parameter queryParams.sliceStart was null or undefined when calling getSampleSlice.');
        }


        if (queryParams?.sliceStart !== undefined) {
            localVarQueryParameters['sliceStart'] = ObjectSerializer.serialize(queryParams.sliceStart, "number");
        }

        if (queryParams?.sliceEnd !== undefined) {
            localVarQueryParameters['sliceEnd'] = ObjectSerializer.serialize(queryParams.sliceEnd, "number");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetSampleResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetSampleResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Get the original, uncropped, downsampled data.
     * @summary Get the original downsampled data
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param limitPayloadValues Limit the number of payload values in the response
     * @param zoomStart Zoom into the sample, with the focus starting at this index
     * @param zoomEnd Zoom into the sample, with the focus ending at this index
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getUncroppedDownsampledSample (projectId: number, sampleId: number, queryParams?: getUncroppedDownsampledSampleQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/original'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getUncroppedDownsampledSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getUncroppedDownsampledSample.');
        }

        if (queryParams?.limitPayloadValues !== undefined) {
            localVarQueryParameters['limitPayloadValues'] = ObjectSerializer.serialize(queryParams.limitPayloadValues, "number");
        }

        if (queryParams?.zoomStart !== undefined) {
            localVarQueryParameters['zoomStart'] = ObjectSerializer.serialize(queryParams.zoomStart, "number");
        }

        if (queryParams?.zoomEnd !== undefined) {
            localVarQueryParameters['zoomEnd'] = ObjectSerializer.serialize(queryParams.zoomEnd, "number");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GetSampleResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetSampleResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * t-SNE2 output of the raw dataset
     * @summary Check data explorer features
     * @param projectId Project ID
     */
    public async hasDataExplorerFeatures (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/has-features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasDataExplorerFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<HasDataExplorerFeaturesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "HasDataExplorerFeaturesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Determine if data diversity metrics have been calculated. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Check if data diversity metrics exist
     * @param projectId Project ID
     */
    public async hasDiversityData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/diversity/exists'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasDiversityData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<HasDataExplorerFeaturesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "HasDataExplorerFeaturesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Determine if label noise metrics have been calculated. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Check if label noise metrics exist
     * @param projectId Project ID
     */
    public async hasLabelNoiseData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/label-noise/exists'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasLabelNoiseData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<HasDataExplorerFeaturesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "HasDataExplorerFeaturesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Retrieve all raw data by category.
     * @summary List samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     * @param excludeSensors Whether to exclude sensors in the response (as these can slow down requests when you have large pages).
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param proposedActionsJobId Pass this parameter when querying samples from inside an AI Action job. If you pass this parameter in a multi-stage AI Action, previous proposed changes (from an earlier step) will be applied to the returned dataset.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     * @param sortBy If not specified, \&quot;id-desc\&quot; is used.
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async listSamples (projectId: number, queryParams: listSamplesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListSamplesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listSamples.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling listSamples.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        if (queryParams?.excludeSensors !== undefined) {
            localVarQueryParameters['excludeSensors'] = ObjectSerializer.serialize(queryParams.excludeSensors, "boolean");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.proposedActionsJobId !== undefined) {
            localVarQueryParameters['proposedActionsJobId'] = ObjectSerializer.serialize(queryParams.proposedActionsJobId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        if (queryParams?.sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(queryParams.sortBy, "'id-desc' | 'random'");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<ListSamplesResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ListSamplesResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Move a sample to another category (e.g. from test to training).
     * @summary Move sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param moveRawDataRequest 
     */
    public async moveSample (projectId: number, sampleId: number, moveRawDataRequest: MoveRawDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/move'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling moveSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling moveSample.');
        }

        // verify required parameter 'moveRawDataRequest' is not null or undefined


        if (moveRawDataRequest === null || moveRawDataRequest === undefined) {
            throw new Error('Required parameter moveRawDataRequest was null or undefined when calling moveSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(moveRawDataRequest, "MoveRawDataRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Clears the bounding box labels and moves item back to labeling queue
     * @summary Move sample to labeling queue
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async moveToLabelingQueue (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/to-labeling-queue'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling moveToLabelingQueue.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling moveToLabelingQueue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * This API is deprecated, use rebalanceDatasetV2 instead (`/v1/api/{projectId}/v2/rebalance`). Rebalances the dataset over training / testing categories. This resets the category for all data and splits it 80%/20% between training and testing. This is a deterministic process based on the hash of the name of the data.
     * @summary Rebalance dataset
     * @param projectId Project ID
     */
    public async rebalanceDataset (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<RebalanceDatasetResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/rebalance'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling rebalanceDataset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<RebalanceDatasetResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RebalanceDatasetResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Rebalances the dataset over training / testing categories. This resets the category for all data and splits it 80%/20% between training and testing. This is a deterministic process based on the hash of the name of the data. Returns immediately on small datasets, or starts a job on larger datasets. To get the dataset ratio (as returned by the v1 endpoint), use getDatasetRatio.
     * @summary Rebalance dataset
     * @param projectId Project ID
     */
    public async rebalanceDatasetV2 (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/v2/rebalance'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling rebalanceDatasetV2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Sets the file name of the sample. This name does not need to be unique, but it\'s highly recommended to do so.
     * @summary Rename sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param renameSampleRequest 
     */
    public async renameSample (projectId: number, sampleId: number, renameSampleRequest: RenameSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/rename'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling renameSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling renameSample.');
        }

        // verify required parameter 'renameSampleRequest' is not null or undefined


        if (renameSampleRequest === null || renameSampleRequest === undefined) {
            throw new Error('Required parameter renameSampleRequest was null or undefined when calling renameSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(renameSampleRequest, "RenameSampleRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * If a sample failed processing, retry the processing operation.
     * @summary Retry processing
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async retryProcessing (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/retry-processing'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retryProcessing.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling retryProcessing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Slice a sample into multiple segments. The original file will be marked as deleted, but you can crop any created segment to retrieve the original file.
     * @summary Segment sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param segmentSampleRequest 
     */
    public async segmentSample (projectId: number, sampleId: number, segmentSampleRequest: SegmentSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/segment'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling segmentSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling segmentSample.');
        }

        // verify required parameter 'segmentSampleRequest' is not null or undefined


        if (segmentSampleRequest === null || segmentSampleRequest === undefined) {
            throw new Error('Required parameter segmentSampleRequest was null or undefined when calling segmentSample.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(segmentSampleRequest, "SegmentSampleRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Set data explorer configuration, like the type of data, and the input / dsp block to use.
     * @summary Set data explorer settings
     * @param projectId Project ID
     * @param dataExplorerSettings 
     */
    public async setDataExplorerSettings (projectId: number, dataExplorerSettings: DataExplorerSettings, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/settings'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setDataExplorerSettings.');
        }

        // verify required parameter 'dataExplorerSettings' is not null or undefined


        if (dataExplorerSettings === null || dataExplorerSettings === undefined) {
            throw new Error('Required parameter dataExplorerSettings was null or undefined when calling setDataExplorerSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(dataExplorerSettings, "DataExplorerSettings")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Set the bounding boxes for a sample
     * @summary Set bounding boxes
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param sampleBoundingBoxesRequest 
     */
    public async setSampleBoundingBoxes (projectId: number, sampleId: number, sampleBoundingBoxesRequest: SampleBoundingBoxesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/bounding-boxes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleBoundingBoxes.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleBoundingBoxes.');
        }

        // verify required parameter 'sampleBoundingBoxesRequest' is not null or undefined


        if (sampleBoundingBoxesRequest === null || sampleBoundingBoxesRequest === undefined) {
            throw new Error('Required parameter sampleBoundingBoxesRequest was null or undefined when calling setSampleBoundingBoxes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(sampleBoundingBoxesRequest, "SampleBoundingBoxesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Adds or updates the metadata associated to a sample.
     * @summary Set sample metadata
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleMetadataRequest 
     */
    public async setSampleMetadata (projectId: number, sampleId: number, setSampleMetadataRequest: SetSampleMetadataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleMetadata.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleMetadata.');
        }

        // verify required parameter 'setSampleMetadataRequest' is not null or undefined


        if (setSampleMetadataRequest === null || setSampleMetadataRequest === undefined) {
            throw new Error('Required parameter setSampleMetadataRequest was null or undefined when calling setSampleMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(setSampleMetadataRequest, "SetSampleMetadataRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Queue up changes to an object as part of the AI Actions flow. This overwrites any previous proposed changes.
     * @summary Propose changes
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleProposedChangesRequest 
     */
    public async setSampleProposedChanges (projectId: number, sampleId: number, setSampleProposedChangesRequest: SetSampleProposedChangesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/propose-changes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleProposedChanges.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleProposedChanges.');
        }

        // verify required parameter 'setSampleProposedChangesRequest' is not null or undefined


        if (setSampleProposedChangesRequest === null || setSampleProposedChangesRequest === undefined) {
            throw new Error('Required parameter setSampleProposedChangesRequest was null or undefined when calling setSampleProposedChanges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(setSampleProposedChangesRequest, "SetSampleProposedChangesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Set structured labels for a sample. If a sample has structured labels the `label` column is ignored, and the sample is allowed to have multiple labels. An array of { startIndex, endIndex, label } needs to be passed in with labels for the complete sample (see `valuesCount` to get the upper bound). endIndex is _inclusive_. If you pass in an incorrect array (e.g. missing values) you\'ll get an error back.
     * @summary Update structured labels
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleStructuredLabelsRequest 
     */
    public async setSampleStructuredLabels (projectId: number, sampleId: number, setSampleStructuredLabelsRequest: SetSampleStructuredLabelsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/structured-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleStructuredLabels.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleStructuredLabels.');
        }

        // verify required parameter 'setSampleStructuredLabelsRequest' is not null or undefined


        if (setSampleStructuredLabelsRequest === null || setSampleStructuredLabelsRequest === undefined) {
            throw new Error('Required parameter setSampleStructuredLabelsRequest was null or undefined when calling setSampleStructuredLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(setSampleStructuredLabelsRequest, "SetSampleStructuredLabelsRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Update the video dimensions for a sample. This is only available for video files that do not have dimensions set yet.
     * @summary Set sample video dimensions
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleVideoDimensionsRequest 
     */
    public async setSampleVideoDimensions (projectId: number, sampleId: number, setSampleVideoDimensionsRequest: SetSampleVideoDimensionsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/video-dimensions'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleVideoDimensions.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleVideoDimensions.');
        }

        // verify required parameter 'setSampleVideoDimensionsRequest' is not null or undefined


        if (setSampleVideoDimensionsRequest === null || setSampleVideoDimensionsRequest === undefined) {
            throw new Error('Required parameter setSampleVideoDimensionsRequest was null or undefined when calling setSampleVideoDimensions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(setSampleVideoDimensionsRequest, "SetSampleVideoDimensionsRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Split a video sample into individual frames. Depending on the length of the video sample this will either execute immediately or return the ID of a job that will perform this action. 
     * @summary Split sample into frames
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param splitSampleInFramesRequest 
     */
    public async splitSampleInFrames (projectId: number, sampleId: number, splitSampleInFramesRequest: SplitSampleInFramesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/split'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling splitSampleInFrames.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling splitSampleInFrames.');
        }

        // verify required parameter 'splitSampleInFramesRequest' is not null or undefined


        if (splitSampleInFramesRequest === null || splitSampleInFramesRequest === undefined) {
            throw new Error('Required parameter splitSampleInFramesRequest was null or undefined when calling splitSampleInFrames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(splitSampleInFramesRequest, "SplitSampleInFramesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse | StartJobResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse | StartJobResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * When segmenting a sample into smaller segments, store the segment length to ensure uniform segment lengths.
     * @summary Store the last segment length
     * @param projectId Project ID
     * @param storeSegmentLengthRequest 
     */
    public async storeSegmentLength (projectId: number, storeSegmentLengthRequest: StoreSegmentLengthRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/store-segment-length'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling storeSegmentLength.');
        }

        // verify required parameter 'storeSegmentLengthRequest' is not null or undefined


        if (storeSegmentLengthRequest === null || storeSegmentLengthRequest === undefined) {
            throw new Error('Required parameter storeSegmentLengthRequest was null or undefined when calling storeSegmentLength.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(storeSegmentLengthRequest, "StoreSegmentLengthRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Track objects between two samples. Source sample should have bounding boxes set.
     * @summary Track objects
     * @param projectId Project ID
     * @param trackObjectsRequest 
     */
    public async trackObjects (projectId: number, trackObjectsRequest: TrackObjectsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<TrackObjectsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/track-objects'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling trackObjects.');
        }

        // verify required parameter 'trackObjectsRequest' is not null or undefined


        if (trackObjectsRequest === null || trackObjectsRequest === undefined) {
            throw new Error('Required parameter trackObjectsRequest was null or undefined when calling trackObjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
            body: ObjectSerializer.serialize(trackObjectsRequest, "TrackObjectsRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<TrackObjectsResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TrackObjectsResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }

    /**
     * Used internally (from a data pipeline) to upload a picture of the data explorer
     * @summary Upload a data explorer screenshot
     * @param projectId Project ID
     * @param image 
     */
    public async uploadDataExplorerScreenshot (projectId: number, params: uploadDataExplorerScreenshotFormParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/screenshot'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({
            'User-Agent': 'edgeimpulse-api nodejs'
        }, this.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling uploadDataExplorerScreenshot.');
        }

        // verify required parameter 'image' is not null or undefined
        if (params.image === null || params.image === undefined) {
            throw new Error('Required parameter params.image was null or undefined when calling uploadDataExplorerScreenshot.');
        }



        (<any>Object).assign(localVarHeaderParams, options.headers);
        (<any>Object).assign(localVarHeaderParams, this.opts.extraHeaders);

        let localVarUseFormData = false;

        if (params.image !== undefined) {
            localVarFormParams['image'] = params.image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            agentOptions: {keepAlive: false},
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.ApiKeyAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.JWTHttpHeaderAuthentication.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<GenericApiResponse>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GenericApiResponse");

                        if (typeof body.success === 'boolean' && !body.success) {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(new Error(body.error || errString));
                        }
                        else if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        }
                        else {
                            const errString = `Failed to call "${localVarPath}", returned ${response.statusCode}: ` + response.body;
                            reject(errString);
                        }
                    }
                });
            });
        });
    }
}

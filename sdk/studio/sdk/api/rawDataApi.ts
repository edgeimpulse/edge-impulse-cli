/**
 * Edge Impulse API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

const PATH = require('path');
module.paths.push(PATH.join(process.cwd(), 'node_modules'));

import type { fetch as UndiciFetch, FormData as UndiciFormData, Response as UndiciResponse } from 'undici-types';

let fetch: typeof globalThis.fetch | typeof UndiciFetch;
let FormData: typeof globalThis.FormData | typeof UndiciFormData;

if (globalThis.fetch && globalThis.FormData) {
    fetch = globalThis.fetch;
    FormData = globalThis.FormData;
}
else {
    const undici = require('undici');
    fetch = undici.fetch;
    FormData = undici.FormData;
}

import { BackToLabelingRequest } from '../model/backToLabelingRequest';
import { BatchAddMetadataRequest } from '../model/batchAddMetadataRequest';
import { BatchClearMetadataByKeyRequest } from '../model/batchClearMetadataByKeyRequest';
import { BatchEditBoundingBoxesRequest } from '../model/batchEditBoundingBoxesRequest';
import { CountSamplesResponse } from '../model/countSamplesResponse';
import { CropSampleRequest } from '../model/cropSampleRequest';
import { CropSampleResponse } from '../model/cropSampleResponse';
import { DataExplorerPredictionsResponse } from '../model/dataExplorerPredictionsResponse';
import { DataExplorerSettings } from '../model/dataExplorerSettings';
import { EditSampleLabelRequest } from '../model/editSampleLabelRequest';
import { FindSegmentSampleRequest } from '../model/findSegmentSampleRequest';
import { FindSegmentSampleResponse } from '../model/findSegmentSampleResponse';
import { GenericApiResponse } from '../model/genericApiResponse';
import { StartJobResponse } from '../model/startJobResponse';
import { GetAIActionsProposedChangesResponse } from '../model/getAIActionsProposedChangesResponse';
import { GetAllImportedFromResponse } from '../model/getAllImportedFromResponse';
import { GetDataExplorerFeaturesResponse } from '../model/getDataExplorerFeaturesResponse';
import { GetDataExplorerSettingsResponse } from '../model/getDataExplorerSettingsResponse';
import { GetDatasetRatioResponse } from '../model/getDatasetRatioResponse';
import { GetDiversityDataResponse } from '../model/getDiversityDataResponse';
import { GetLabelNoiseDataResponse } from '../model/getLabelNoiseDataResponse';
import { GetSampleMetadataFilterOptionsResponse } from '../model/getSampleMetadataFilterOptionsResponse';
import { GetSampleMetadataResponse } from '../model/getSampleMetadataResponse';
import { GetSampleResponse } from '../model/getSampleResponse';
import { HasDataExplorerFeaturesResponse } from '../model/hasDataExplorerFeaturesResponse';
import { ListSamplesResponse } from '../model/listSamplesResponse';
import { MoveRawDataRequest } from '../model/moveRawDataRequest';
import { ObjectDetectionAutoLabelRequest } from '../model/objectDetectionAutoLabelRequest';
import { ObjectDetectionAutoLabelResponse } from '../model/objectDetectionAutoLabelResponse';
import { ObjectDetectionLabelQueueCountResponse } from '../model/objectDetectionLabelQueueCountResponse';
import { ObjectDetectionLabelQueueResponse } from '../model/objectDetectionLabelQueueResponse';
import { RawDataCategory } from '../model/rawDataCategory';
import { RebalanceDatasetResponse } from '../model/rebalanceDatasetResponse';
import { RenameSampleRequest } from '../model/renameSampleRequest';
import { SampleBoundingBoxesRequest } from '../model/sampleBoundingBoxesRequest';
import { SegmentSampleRequest } from '../model/segmentSampleRequest';
import { SetSampleMetadataRequest } from '../model/setSampleMetadataRequest';
import { SetSampleProposedChangesRequest } from '../model/setSampleProposedChangesRequest';
import { SetSampleStructuredLabelsRequest } from '../model/setSampleStructuredLabelsRequest';
import { SetSampleVideoDimensionsRequest } from '../model/setSampleVideoDimensionsRequest';
import { SplitSampleInFramesRequest } from '../model/splitSampleInFramesRequest';
import { StoreSegmentLengthRequest } from '../model/storeSegmentLengthRequest';
import { TrackObjectsRequest } from '../model/trackObjectsRequest';
import { TrackObjectsResponse } from '../model/trackObjectsResponse';

import { ObjectSerializer, Authentication, VoidAuth, RequestOptionsType } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://studio.edgeimpulse.com/v1';

async function parseResponse(res: Response | UndiciResponse): Promise<any> {
    const ct = (res.headers.get('content-type') || '').toLowerCase();

    if (ct.includes('application/json')) return res.json();

    if (/^(image|video|audio)\/|application\/(octet-stream|zip|x-tar|cbor)/.test(ct)) {
        return Buffer.from(await res.arrayBuffer());
    }

    return res.text();
}

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RawDataApiApiKeys {
    ApiKeyAuthentication,
    JWTAuthentication,
    JWTHttpHeaderAuthentication,
}

type batchAddMetadataQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchBackToLabelingQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchClearMetadataQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchClearMetadataByKeyQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchDeleteQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchDisableQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEditBoundingBoxesQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEditLabelsQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchEnableQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type batchMoveQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    ids?: string,
    excludeIds?: string,
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type countSamplesQueryParams = {
    category: RawDataCategory,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

type getAllImportedFromQueryParams = {
    limit?: number,
    offset?: number,
};

type getSampleQueryParams = {
    limitPayloadValues?: number,
    cacheKey?: string,
    impulseId?: number,
    proposedActionsJobId?: number,
    truncateStructuredLabels?: boolean,
};

type getSampleAsAudioQueryParams = {
    axisIx: number,
    sliceStart?: number,
    sliceEnd?: number,
    cacheKey?: string,
};

type getSampleAsImageQueryParams = {
    afterInputBlock?: boolean,
    cacheKey?: string,
    impulseId?: number,
};

type getSampleAsVideoQueryParams = {
    afterInputBlock?: boolean,
    cacheKey?: string,
    impulseId?: number,
};

type getSampleMetadataQueryParams = {
    category: RawDataCategory,
};

type getSampleMetadataFilterOptionsQueryParams = {
    category: RawDataCategory,
    limit?: number,
    offset?: number,
};

type getSampleSliceQueryParams = {
    sliceStart: number,
    sliceEnd?: number,
    impulseId?: number,
    truncateStructuredLabels?: boolean,
};

type getUncroppedDownsampledSampleQueryParams = {
    limitPayloadValues?: number,
    zoomStart?: number,
    zoomEnd?: number,
    impulseId?: number,
    truncateStructuredLabels?: boolean,
};

type listSamplesQueryParams = {
    category: RawDataCategory,
    limit?: number,
    offset?: number,
    excludeSensors?: boolean,
    labels?: string,
    filename?: string,
    maxLength?: number,
    minLength?: number,
    minFrequency?: number,
    maxFrequency?: number,
    signatureValidity?: 'both' | 'valid' | 'invalid',
    includeDisabled?: 'both' | 'enabled' | 'disabled',
    minLabel?: number,
    maxLabel?: number,
    search?: string,
    proposedActionsJobId?: number,
    truncateStructuredLabels?: boolean,
    sortBy?: 'id-desc' | 'random',
    dataType?: 'audio' | 'image',
    minId?: number,
    maxId?: number,
    metadata?: string,
    minDate?: Date,
    maxDate?: Date,
};

export type uploadDataExplorerScreenshotFormParams = {
    image: RequestFile,
};


export type RawDataApiOpts = {
    extraHeaders?: Record<string, string>;
};

export class RawDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : Record<string, string> = {};
    protected _opts : RawDataApiOpts = { };

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuthentication': new ApiKeyAuth('header', 'x-api-key'),
        'OAuth2': new OAuth(),
        'JWTAuthentication': new ApiKeyAuth('cookie', 'jwt'),
        'JWTHttpHeaderAuthentication': new ApiKeyAuth('header', 'x-jwt-token'),
    }

    protected async handleResponse(response: Response | UndiciResponse, returnType: string | undefined): Promise<any> {
        let body = await parseResponse(response);
        if (!response.ok) {
            let errorMsg;
            if (typeof body === 'object' && body !== null && 'error' in body) {
                errorMsg = body.error;
            } else {
                errorMsg = `Failed to call "${response.url}", returned ${response.status}: ` + (typeof body === 'string' ? body : JSON.stringify(body));
            }
            throw new Error(errorMsg);
        }

        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        if (typeof body.success === 'boolean' && !body.success) {
            const errString = `Failed to call "${response.url}", returned ${response.status}: ` + body.error;
            throw new Error(body.error || errString);
        }

        return body;
    }

    constructor(basePath?: string, opts?: RawDataApiOpts);
    constructor(basePathOrUsername: string, opts?: RawDataApiOpts, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }

        this.opts = opts ?? { };
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set opts(opts: RawDataApiOpts) {
        this._opts = opts;
    }

    get opts() {
        return this._opts;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RawDataApiApiKeys, value: string | undefined) {
        (this.authentications as any)[RawDataApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }


    /**
     * Add specific metadata for multiple samples.
     * @summary Add metadata (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchAddMetadataRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchAddMetadata (projectId: number, batchAddMetadataRequest: BatchAddMetadataRequest, queryParams: batchAddMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/add-metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchAddMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchAddMetadata.');
        }


        // verify required parameter 'batchAddMetadataRequest' is not null or undefined


        if (batchAddMetadataRequest === null || batchAddMetadataRequest === undefined) {
            throw new Error('Required parameter batchAddMetadataRequest was null or undefined when calling batchAddMetadata.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(batchAddMetadataRequest, "BatchAddMetadataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Batch operation to put multiple samples back into the object detection labeling queue. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Put samples back into the object detection labeling queue
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param backToLabelingRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchBackToLabeling (projectId: number, backToLabelingRequest: BackToLabelingRequest, queryParams: batchBackToLabelingQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/back-to-labeling'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchBackToLabeling.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchBackToLabeling.');
        }


        // verify required parameter 'backToLabelingRequest' is not null or undefined


        if (backToLabelingRequest === null || backToLabelingRequest === undefined) {
            throw new Error('Required parameter backToLabelingRequest was null or undefined when calling batchBackToLabeling.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(backToLabelingRequest, "BackToLabelingRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Clears all metadata for multiple samples.
     * @summary Clear all metadata (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchClearMetadata (projectId: number, queryParams: batchClearMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/clear-metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchClearMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchClearMetadata.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Clears a specific metadata field (by key) for multiple samples.
     * @summary Clear metadata by key (multiple samples)
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchClearMetadataByKeyRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchClearMetadataByKey (projectId: number, batchClearMetadataByKeyRequest: BatchClearMetadataByKeyRequest, queryParams: batchClearMetadataByKeyQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/clear-metadata-by-key'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchClearMetadataByKey.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchClearMetadataByKey.');
        }


        // verify required parameter 'batchClearMetadataByKeyRequest' is not null or undefined


        if (batchClearMetadataByKeyRequest === null || batchClearMetadataByKeyRequest === undefined) {
            throw new Error('Required parameter batchClearMetadataByKeyRequest was null or undefined when calling batchClearMetadataByKey.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(batchClearMetadataByKeyRequest, "BatchClearMetadataByKeyRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Deletes samples. Note that this does not delete the data from cold storage. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Remove multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchDelete (projectId: number, queryParams: batchDeleteQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/delete'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchDelete.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchDelete.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Disables samples, ensuring that they are excluded from the dataset. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Disable multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchDisable (projectId: number, queryParams: batchDisableQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/disable-samples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchDisable.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchDisable.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Relabels (or removes) bounding boxes for multiple samples. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Edit bounding boxes for multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param batchEditBoundingBoxesRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEditBoundingBoxes (projectId: number, batchEditBoundingBoxesRequest: BatchEditBoundingBoxesRequest, queryParams: batchEditBoundingBoxesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/edit-bounding-boxes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEditBoundingBoxes.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEditBoundingBoxes.');
        }


        // verify required parameter 'batchEditBoundingBoxesRequest' is not null or undefined


        if (batchEditBoundingBoxesRequest === null || batchEditBoundingBoxesRequest === undefined) {
            throw new Error('Required parameter batchEditBoundingBoxesRequest was null or undefined when calling batchEditBoundingBoxes.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(batchEditBoundingBoxesRequest, "BatchEditBoundingBoxesRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Sets the label (also known as class) of multiple samples. If you want to relabel bounding boxes, use \"batchEditBoundingBoxes\" instead. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Edit labels for multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param editSampleLabelRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEditLabels (projectId: number, editSampleLabelRequest: EditSampleLabelRequest, queryParams: batchEditLabelsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/edit-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEditLabels.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEditLabels.');
        }


        // verify required parameter 'editSampleLabelRequest' is not null or undefined


        if (editSampleLabelRequest === null || editSampleLabelRequest === undefined) {
            throw new Error('Required parameter editSampleLabelRequest was null or undefined when calling batchEditLabels.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(editSampleLabelRequest, "EditSampleLabelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Enables samples, ensuring that they are not excluded from the dataset. Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Enable multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchEnable (projectId: number, queryParams: batchEnableQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/enable-samples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchEnable.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchEnable.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Move multiple samples to another category (e.g. from test to training). Depending on the number of affected samples this will either execute immediately or return the ID of a job that will perform this action in batches. 
     * @summary Move multiple samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param moveRawDataRequest 
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param ids Only include samples with an ID within the given list of IDs, given as a JSON string
     * @param excludeIds Exclude samples with an ID within the given list of IDs, given as a JSON string
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async batchMove (projectId: number, moveRawDataRequest: MoveRawDataRequest, queryParams: batchMoveQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/batch/moveSamples'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling batchMove.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling batchMove.');
        }


        // verify required parameter 'moveRawDataRequest' is not null or undefined


        if (moveRawDataRequest === null || moveRawDataRequest === undefined) {
            throw new Error('Required parameter moveRawDataRequest was null or undefined when calling batchMove.');
        }

        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(queryParams.ids, "string");
        }

        if (queryParams?.excludeIds !== undefined) {
            localVarQueryParameters['excludeIds'] = ObjectSerializer.serialize(queryParams.excludeIds, "string");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(moveRawDataRequest, "MoveRawDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Classify an image using another neural network.
     * @summary Auto-label an image
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param objectDetectionAutoLabelRequest 
     */
    public async classifyUsingAutolabel (projectId: number, sampleId: number, objectDetectionAutoLabelRequest: ObjectDetectionAutoLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionAutoLabelResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/autolabel'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling classifyUsingAutolabel.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling classifyUsingAutolabel.');
        }

        // verify required parameter 'objectDetectionAutoLabelRequest' is not null or undefined


        if (objectDetectionAutoLabelRequest === null || objectDetectionAutoLabelRequest === undefined) {
            throw new Error('Required parameter objectDetectionAutoLabelRequest was null or undefined when calling classifyUsingAutolabel.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(objectDetectionAutoLabelRequest, "ObjectDetectionAutoLabelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ObjectDetectionAutoLabelResponse'
        );
    }

    /**
     * Clears all object detection labels for this dataset, and places all images back in the labeling queue.
     * @summary Clear all object detection labels
     * @param projectId Project ID
     */
    public async clearAllObjectDetectionLabels (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/clear-all-object-detection-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling clearAllObjectDetectionLabels.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Remove the current data explorer state
     * @summary Clear data explorer
     * @param projectId Project ID
     */
    public async clearDataExplorer (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/clear'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling clearDataExplorer.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Count all raw data by category.
     * @summary Count samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async countSamples (projectId: number, queryParams: countSamplesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<CountSamplesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/count'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling countSamples.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling countSamples.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'CountSamplesResponse'
        );
    }

    /**
     * Crop a sample to within a new range.
     * @summary Crop sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param cropSampleRequest 
     */
    public async cropSample (projectId: number, sampleId: number, cropSampleRequest: CropSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<CropSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/crop'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling cropSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling cropSample.');
        }

        // verify required parameter 'cropSampleRequest' is not null or undefined


        if (cropSampleRequest === null || cropSampleRequest === undefined) {
            throw new Error('Required parameter cropSampleRequest was null or undefined when calling cropSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(cropSampleRequest, "CropSampleRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'CropSampleResponse'
        );
    }

    /**
     * Deletes all samples for this project over all categories. This also invalidates all DSP and learn blocks. Note that this does not delete the data from cold storage.
     * @summary Remove all samples
     * @param projectId Project ID
     */
    public async deleteAllSamples (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/delete-all'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteAllSamples.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Deletes all samples for this project over a single category. Note that this does not delete the data from cold storage.
     * @summary Remove all samples by category
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to download data from
     */
    public async deleteAllSamplesByCategory (projectId: number, category: RawDataCategory, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/delete-all/{category}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteAllSamplesByCategory.');
        }

        // verify required parameter 'category' is not null or undefined


        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling deleteAllSamplesByCategory.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Deletes the sample. Note that this does not delete the data from cold storage.
     * @summary Remove sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async deleteSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling deleteSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'DELETE',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Disable a sample, ensuring that it is excluded from the dataset.
     * @summary Disable sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async disableSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/disable'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling disableSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling disableSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Sets the label (also known as class) of the sample. Use the same label for similar types of data, as they are used during training.
     * @summary Edit label
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param editSampleLabelRequest 
     */
    public async editLabel (projectId: number, sampleId: number, editSampleLabelRequest: EditSampleLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/edit-label'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling editLabel.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling editLabel.');
        }

        // verify required parameter 'editSampleLabelRequest' is not null or undefined


        if (editSampleLabelRequest === null || editSampleLabelRequest === undefined) {
            throw new Error('Required parameter editSampleLabelRequest was null or undefined when calling editLabel.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(editSampleLabelRequest, "EditSampleLabelRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Enable a sample, ensuring that it is not excluded from the dataset.
     * @summary Enable sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async enableSample (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/enable'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling enableSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling enableSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Find start and end times for all non-noise events in a sample
     * @summary Find segments
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param findSegmentSampleRequest 
     */
    public async findSegmentsInSample (projectId: number, sampleId: number, findSegmentSampleRequest: FindSegmentSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<FindSegmentSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/find-segments'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findSegmentsInSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling findSegmentsInSample.');
        }

        // verify required parameter 'findSegmentSampleRequest' is not null or undefined


        if (findSegmentSampleRequest === null || findSegmentSampleRequest === undefined) {
            throw new Error('Required parameter findSegmentSampleRequest was null or undefined when calling findSegmentsInSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(findSegmentSampleRequest, "FindSegmentSampleRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'FindSegmentSampleResponse'
        );
    }

    /**
     * Get proposed changes from an AI Actions job.
     * @summary Get AI Actions proposed changes
     * @param projectId Project ID
     * @param jobId Job ID
     */
    public async getAIActionsProposedChanges (projectId: number, jobId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetAIActionsProposedChangesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/ai-actions-preview/{jobId}/proposed-changes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAIActionsProposedChanges.');
        }

        // verify required parameter 'jobId' is not null or undefined


        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getAIActionsProposedChanges.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetAIActionsProposedChangesResponse'
        );
    }

    /**
     * Lists all data with an \'imported from\' metadata key. Used to check in a data source which items are already in a project.
     * @summary List data with \"imported from\" metadata key
     * @param projectId Project ID
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async getAllImportedFrom (projectId: number, queryParams?: getAllImportedFromQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetAllImportedFromResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/imported-from'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAllImportedFrom.');
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetAllImportedFromResponse'
        );
    }

    /**
     * t-SNE2 output of the raw dataset
     * @summary Get data explorer features
     * @param projectId Project ID
     */
    public async getDataExplorerFeatures (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerFeatures.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetDataExplorerFeaturesResponse'
        );
    }

    /**
     * Predictions for every data explorer point (only available when using current impulse to populate data explorer)
     * @summary Get data explorer predictions
     * @param projectId Project ID
     */
    public async getDataExplorerPredictions (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<DataExplorerPredictionsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/predictions'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerPredictions.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'DataExplorerPredictionsResponse'
        );
    }

    /**
     * Get data explorer configuration, like the type of data, and the input / dsp block to use.
     * @summary Get data explorer settings
     * @param projectId Project ID
     */
    public async getDataExplorerSettings (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDataExplorerSettingsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/settings'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDataExplorerSettings.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetDataExplorerSettingsResponse'
        );
    }

    /**
     * Retrieve number of samples in train and test set.
     * @summary Get dataset ratio
     * @param projectId Project ID
     */
    public async getDatasetRatio (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDatasetRatioResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/ratio'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDatasetRatio.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetDatasetRatioResponse'
        );
    }

    /**
     * Obtain metrics that describe the similarity and diversity of a dataset. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Get diversity metrics data
     * @param projectId Project ID
     */
    public async getDiversityData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetDiversityDataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/diversity'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDiversityData.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetDiversityDataResponse'
        );
    }

    /**
     * Obtain metrics that describe potential label noise issues in the dataset. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Get label noise data
     * @param projectId Project ID
     */
    public async getLabelNoiseData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetLabelNoiseDataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/label-noise'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getLabelNoiseData.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetLabelNoiseDataResponse'
        );
    }

    /**
     * Get all unlabeled items from the object detection queue.
     * @summary Object detection label queue
     * @param projectId Project ID
     */
    public async getObjectDetectionLabelQueue (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionLabelQueueResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/label-object-detection-queue'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getObjectDetectionLabelQueue.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ObjectDetectionLabelQueueResponse'
        );
    }

    /**
     * Get count for unlabeled items from the object detection queue.
     * @summary Object detection label queue count
     * @param projectId Project ID
     */
    public async getObjectDetectionLabelQueueCount (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ObjectDetectionLabelQueueCountResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/label-object-detection-queue/count'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getObjectDetectionLabelQueueCount.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ObjectDetectionLabelQueueCountResponse'
        );
    }

    /**
     * Get a sample.
     * @summary Get sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param limitPayloadValues Limit the number of payload values in the response
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param proposedActionsJobId Pass this parameter when querying samples from inside an AI Action job. If you pass this parameter in a multi-stage AI Action, previous proposed changes (from an earlier step) will be applied to the returned dataset.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getSample (projectId: number, sampleId: number, queryParams?: getSampleQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSample.');
        }

        if (queryParams?.limitPayloadValues !== undefined) {
            localVarQueryParameters['limitPayloadValues'] = ObjectSerializer.serialize(queryParams.limitPayloadValues, "number");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.proposedActionsJobId !== undefined) {
            localVarQueryParameters['proposedActionsJobId'] = ObjectSerializer.serialize(queryParams.proposedActionsJobId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetSampleResponse'
        );
    }

    /**
     * Get a sample as a WAV file. This only applies to samples with an audio axis.
     * @summary Get WAV file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param axisIx Axis index
     * @param sliceStart Begin index of the slice. If not given, the whole sample is used.
     * @param sliceEnd End index of the slice. If not given, the whole sample is used.
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     */
    public async getSampleAsAudio (projectId: number, sampleId: number, queryParams: getSampleAsAudioQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/wav'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['audio/wav'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsAudio.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsAudio.');
        }

        // verify required parameter 'axisIx' is not null or undefined

        if (queryParams.axisIx === null || queryParams.axisIx === undefined) {
            throw new Error('Required parameter queryParams.axisIx was null or undefined when calling getSampleAsAudio.');
        }


        if (queryParams?.axisIx !== undefined) {
            localVarQueryParameters['axisIx'] = ObjectSerializer.serialize(queryParams.axisIx, "number");
        }

        if (queryParams?.sliceStart !== undefined) {
            localVarQueryParameters['sliceStart'] = ObjectSerializer.serialize(queryParams.sliceStart, "number");
        }

        if (queryParams?.sliceEnd !== undefined) {
            localVarQueryParameters['sliceEnd'] = ObjectSerializer.serialize(queryParams.sliceEnd, "number");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Get a sample as an image file. This only applies to samples with RGBA data.
     * @summary Get image file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param afterInputBlock Whether to process the image through the input block first
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async getSampleAsImage (projectId: number, sampleId: number, queryParams?: getSampleAsImageQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/image'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['image/jpeg'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsImage.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsImage.');
        }

        if (queryParams?.afterInputBlock !== undefined) {
            localVarQueryParameters['afterInputBlock'] = ObjectSerializer.serialize(queryParams.afterInputBlock, "boolean");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Download a sample in it\'s original format as uploaded to the ingestion service.
     * @summary Download file
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async getSampleAsRaw (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/raw'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsRaw.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsRaw.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Get a sample as an video file. This only applies to samples with video data.
     * @summary Get video file
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param afterInputBlock Whether to process the image through the input block first
     * @param cacheKey If set, then a long cache header is sent. If this is omitted then a no-cache header is sent. You can use this if you f.e. know the last modified date of a sample. Stick the last modified date in the cache key, so the sample can be stored in browser cache (and will automatically be invalidated if the modified date changes).
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     */
    public async getSampleAsVideo (projectId: number, sampleId: number, queryParams?: getSampleAsVideoQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<Buffer> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/video'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['video/mp4'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleAsVideo.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleAsVideo.');
        }

        if (queryParams?.afterInputBlock !== undefined) {
            localVarQueryParameters['afterInputBlock'] = ObjectSerializer.serialize(queryParams.afterInputBlock, "boolean");
        }

        if (queryParams?.cacheKey !== undefined) {
            localVarQueryParameters['cacheKey'] = ObjectSerializer.serialize(queryParams.cacheKey, "string");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'Buffer'
        );
    }

    /**
     * Get metadata for all samples in a project.
     * @summary Get project sample metadata
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     */
    public async getSampleMetadata (projectId: number, queryParams: getSampleMetadataQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleMetadataResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleMetadata.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling getSampleMetadata.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetSampleMetadataResponse'
        );
    }

    /**
     * Get a list of unique key value pairs across all samples in a project that can be applied as filters to the /api/{projectId}/raw-data endpoint
     * @summary Get project sample metadata filter options
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     */
    public async getSampleMetadataFilterOptions (projectId: number, queryParams: getSampleMetadataFilterOptionsQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleMetadataFilterOptionsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/metadata-filter-options'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleMetadataFilterOptions.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling getSampleMetadataFilterOptions.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetSampleMetadataFilterOptionsResponse'
        );
    }

    /**
     * Get a slice of a sample.
     * @summary Get sample slice
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param sliceStart Begin index of the slice
     * @param sliceEnd End index of the slice. If not given, the sample will be sliced to the same length as the impulse input block window length.
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getSampleSlice (projectId: number, sampleId: number, queryParams: getSampleSliceQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/slice'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSampleSlice.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getSampleSlice.');
        }

        // verify required parameter 'sliceStart' is not null or undefined

        if (queryParams.sliceStart === null || queryParams.sliceStart === undefined) {
            throw new Error('Required parameter queryParams.sliceStart was null or undefined when calling getSampleSlice.');
        }


        if (queryParams?.sliceStart !== undefined) {
            localVarQueryParameters['sliceStart'] = ObjectSerializer.serialize(queryParams.sliceStart, "number");
        }

        if (queryParams?.sliceEnd !== undefined) {
            localVarQueryParameters['sliceEnd'] = ObjectSerializer.serialize(queryParams.sliceEnd, "number");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetSampleResponse'
        );
    }

    /**
     * Get the original, uncropped, downsampled data.
     * @summary Get the original downsampled data
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param limitPayloadValues Limit the number of payload values in the response
     * @param zoomStart Zoom into the sample, with the focus starting at this index
     * @param zoomEnd Zoom into the sample, with the focus ending at this index
     * @param impulseId Impulse ID. If this is unset then the default impulse is used.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     */
    public async getUncroppedDownsampledSample (projectId: number, sampleId: number, queryParams?: getUncroppedDownsampledSampleQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GetSampleResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/original'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getUncroppedDownsampledSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling getUncroppedDownsampledSample.');
        }

        if (queryParams?.limitPayloadValues !== undefined) {
            localVarQueryParameters['limitPayloadValues'] = ObjectSerializer.serialize(queryParams.limitPayloadValues, "number");
        }

        if (queryParams?.zoomStart !== undefined) {
            localVarQueryParameters['zoomStart'] = ObjectSerializer.serialize(queryParams.zoomStart, "number");
        }

        if (queryParams?.zoomEnd !== undefined) {
            localVarQueryParameters['zoomEnd'] = ObjectSerializer.serialize(queryParams.zoomEnd, "number");
        }

        if (queryParams?.impulseId !== undefined) {
            localVarQueryParameters['impulseId'] = ObjectSerializer.serialize(queryParams.impulseId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GetSampleResponse'
        );
    }

    /**
     * t-SNE2 output of the raw dataset
     * @summary Check data explorer features
     * @param projectId Project ID
     */
    public async hasDataExplorerFeatures (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/has-features'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasDataExplorerFeatures.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'HasDataExplorerFeaturesResponse'
        );
    }

    /**
     * Determine if data diversity metrics have been calculated. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Check if data diversity metrics exist
     * @param projectId Project ID
     */
    public async hasDiversityData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/diversity/exists'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasDiversityData.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'HasDataExplorerFeaturesResponse'
        );
    }

    /**
     * Determine if label noise metrics have been calculated. To calculate these metrics, use the `calculateDataQualityMetrics` endpoint.
     * @summary Check if label noise metrics exist
     * @param projectId Project ID
     */
    public async hasLabelNoiseData (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<HasDataExplorerFeaturesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-quality/label-noise/exists'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling hasLabelNoiseData.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'HasDataExplorerFeaturesResponse'
        );
    }

    /**
     * Retrieve all raw data by category.
     * @summary List samples
     * @param projectId Project ID
     * @param category Which of the three acquisition categories to retrieve data from
     * @param limit Maximum number of results
     * @param offset Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
     * @param excludeSensors Whether to exclude sensors in the response (as these can slow down requests when you have large pages).
     * @param labels Only include samples with a label within the given list of labels, given as a JSON string
     * @param filename Only include samples whose filename includes the given filename
     * @param maxLength Only include samples shorter than the given length, in milliseconds
     * @param minLength Only include samples longer than the given length, in milliseconds
     * @param minFrequency Only include samples with higher frequency than given frequency, in hertz
     * @param maxFrequency Only include samples with lower frequency than given frequency, in hertz
     * @param signatureValidity Include samples with either valid or invalid signatures
     * @param includeDisabled Include only enabled or disabled samples (or both)
     * @param minLabel Only include samples with a label &gt;&#x3D; this value
     * @param maxLabel Only include samples with a label &lt; this value
     * @param search Search query
     * @param proposedActionsJobId Pass this parameter when querying samples from inside an AI Action job. If you pass this parameter in a multi-stage AI Action, previous proposed changes (from an earlier step) will be applied to the returned dataset.
     * @param truncateStructuredLabels If true, only a slice of labels will be returned for samples with multiple labels.
     * @param sortBy If not specified, \&quot;id-desc\&quot; is used.
     * @param dataType Include only samples with a particular data type
     * @param minId Include only samples with an ID &gt;&#x3D; this value
     * @param maxId Include only samples with an ID &lt; this value
     * @param metadata Filter samples by metadata key-value pairs, provided as a JSON string. Each item in the filter list is an object with the following properties:     - \&quot;key\&quot;: Metadata key to filter on.     - \&quot;op\&quot;: Operator (\&quot;eq\&quot; for positive match, \&quot;neq\&quot; for negative match).     - \&quot;values\&quot;: (optional) Array of values to match/exclude. If omitted or empty, matches/excludes all values for the key. In addition to filter objects, the following option objects can be specified:     - { \&quot;no_metadata\&quot;: boolean } - If true, include samples without any metadata     - { \&quot;filters_combinator\&quot;: (\&quot;and\&quot; | \&quot;or\&quot;) } - Specifies the combinator and matching mode:         - \&quot;and\&quot;: All filter items must match (logical AND).         - \&quot;or\&quot;: Any filter item may match (logical OR); samples with metadata keys not present in the filters are included. 
     * @param minDate Only include samples that where added after the date given
     * @param maxDate Only include samples that were added before the date given
     */
    public async listSamples (projectId: number, queryParams: listSamplesQueryParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<ListSamplesResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listSamples.');
        }

        // verify required parameter 'category' is not null or undefined

        if (queryParams.category === null || queryParams.category === undefined) {
            throw new Error('Required parameter queryParams.category was null or undefined when calling listSamples.');
        }


        if (queryParams?.category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(queryParams.category, "RawDataCategory");
        }

        if (queryParams?.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(queryParams.limit, "number");
        }

        if (queryParams?.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(queryParams.offset, "number");
        }

        if (queryParams?.excludeSensors !== undefined) {
            localVarQueryParameters['excludeSensors'] = ObjectSerializer.serialize(queryParams.excludeSensors, "boolean");
        }

        if (queryParams?.labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(queryParams.labels, "string");
        }

        if (queryParams?.filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(queryParams.filename, "string");
        }

        if (queryParams?.maxLength !== undefined) {
            localVarQueryParameters['maxLength'] = ObjectSerializer.serialize(queryParams.maxLength, "number");
        }

        if (queryParams?.minLength !== undefined) {
            localVarQueryParameters['minLength'] = ObjectSerializer.serialize(queryParams.minLength, "number");
        }

        if (queryParams?.minFrequency !== undefined) {
            localVarQueryParameters['minFrequency'] = ObjectSerializer.serialize(queryParams.minFrequency, "number");
        }

        if (queryParams?.maxFrequency !== undefined) {
            localVarQueryParameters['maxFrequency'] = ObjectSerializer.serialize(queryParams.maxFrequency, "number");
        }

        if (queryParams?.signatureValidity !== undefined) {
            localVarQueryParameters['signatureValidity'] = ObjectSerializer.serialize(queryParams.signatureValidity, "'both' | 'valid' | 'invalid'");
        }

        if (queryParams?.includeDisabled !== undefined) {
            localVarQueryParameters['includeDisabled'] = ObjectSerializer.serialize(queryParams.includeDisabled, "'both' | 'enabled' | 'disabled'");
        }

        if (queryParams?.minLabel !== undefined) {
            localVarQueryParameters['minLabel'] = ObjectSerializer.serialize(queryParams.minLabel, "number");
        }

        if (queryParams?.maxLabel !== undefined) {
            localVarQueryParameters['maxLabel'] = ObjectSerializer.serialize(queryParams.maxLabel, "number");
        }

        if (queryParams?.search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(queryParams.search, "string");
        }

        if (queryParams?.proposedActionsJobId !== undefined) {
            localVarQueryParameters['proposedActionsJobId'] = ObjectSerializer.serialize(queryParams.proposedActionsJobId, "number");
        }

        if (queryParams?.truncateStructuredLabels !== undefined) {
            localVarQueryParameters['truncateStructuredLabels'] = ObjectSerializer.serialize(queryParams.truncateStructuredLabels, "boolean");
        }

        if (queryParams?.sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(queryParams.sortBy, "'id-desc' | 'random'");
        }

        if (queryParams?.dataType !== undefined) {
            localVarQueryParameters['dataType'] = ObjectSerializer.serialize(queryParams.dataType, "'audio' | 'image'");
        }

        if (queryParams?.minId !== undefined) {
            localVarQueryParameters['minId'] = ObjectSerializer.serialize(queryParams.minId, "number");
        }

        if (queryParams?.maxId !== undefined) {
            localVarQueryParameters['maxId'] = ObjectSerializer.serialize(queryParams.maxId, "number");
        }

        if (queryParams?.metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(queryParams.metadata, "string");
        }

        if (queryParams?.minDate !== undefined) {
            localVarQueryParameters['minDate'] = ObjectSerializer.serialize(queryParams.minDate, "Date");
        }

        if (queryParams?.maxDate !== undefined) {
            localVarQueryParameters['maxDate'] = ObjectSerializer.serialize(queryParams.maxDate, "Date");
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'GET',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'ListSamplesResponse'
        );
    }

    /**
     * Move a sample to another category (e.g. from test to training).
     * @summary Move sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param moveRawDataRequest 
     */
    public async moveSample (projectId: number, sampleId: number, moveRawDataRequest: MoveRawDataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/move'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling moveSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling moveSample.');
        }

        // verify required parameter 'moveRawDataRequest' is not null or undefined


        if (moveRawDataRequest === null || moveRawDataRequest === undefined) {
            throw new Error('Required parameter moveRawDataRequest was null or undefined when calling moveSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(moveRawDataRequest, "MoveRawDataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Clears the bounding box labels and moves item back to labeling queue
     * @summary Move sample to labeling queue
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async moveToLabelingQueue (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/to-labeling-queue'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling moveToLabelingQueue.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling moveToLabelingQueue.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * This API is deprecated, use rebalanceDatasetV2 instead (`/v1/api/{projectId}/v2/rebalance`). Rebalances the dataset over training / testing categories. This resets the category for all data and splits it 80%/20% between training and testing. This is a deterministic process based on the hash of the name of the data.
     * @summary Rebalance dataset
     * @param projectId Project ID
     */
    public async rebalanceDataset (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<RebalanceDatasetResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/rebalance'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling rebalanceDataset.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'RebalanceDatasetResponse'
        );
    }

    /**
     * Rebalances the dataset over training / testing categories. This resets the category for all data and splits it 80%/20% between training and testing. This is a deterministic process based on the hash of the name of the data. Returns immediately on small datasets, or starts a job on larger datasets. To get the dataset ratio (as returned by the v1 endpoint), use getDatasetRatio.
     * @summary Rebalance dataset
     * @param projectId Project ID
     */
    public async rebalanceDatasetV2 (projectId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/v2/rebalance'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling rebalanceDatasetV2.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * Sets the file name of the sample. This name does not need to be unique, but it\'s highly recommended to do so.
     * @summary Rename sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param renameSampleRequest 
     */
    public async renameSample (projectId: number, sampleId: number, renameSampleRequest: RenameSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/rename'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling renameSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling renameSample.');
        }

        // verify required parameter 'renameSampleRequest' is not null or undefined


        if (renameSampleRequest === null || renameSampleRequest === undefined) {
            throw new Error('Required parameter renameSampleRequest was null or undefined when calling renameSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(renameSampleRequest, "RenameSampleRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * If a sample failed processing, retry the processing operation.
     * @summary Retry processing
     * @param projectId Project ID
     * @param sampleId Sample ID
     */
    public async retryProcessing (projectId: number, sampleId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/retry-processing'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retryProcessing.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling retryProcessing.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Slice a sample into multiple segments. The original file will be marked as deleted, but you can crop any created segment to retrieve the original file.
     * @summary Segment sample
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param segmentSampleRequest 
     */
    public async segmentSample (projectId: number, sampleId: number, segmentSampleRequest: SegmentSampleRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/segment'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling segmentSample.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling segmentSample.');
        }

        // verify required parameter 'segmentSampleRequest' is not null or undefined


        if (segmentSampleRequest === null || segmentSampleRequest === undefined) {
            throw new Error('Required parameter segmentSampleRequest was null or undefined when calling segmentSample.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(segmentSampleRequest, "SegmentSampleRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Set data explorer configuration, like the type of data, and the input / dsp block to use.
     * @summary Set data explorer settings
     * @param projectId Project ID
     * @param dataExplorerSettings 
     */
    public async setDataExplorerSettings (projectId: number, dataExplorerSettings: DataExplorerSettings, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/settings'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setDataExplorerSettings.');
        }

        // verify required parameter 'dataExplorerSettings' is not null or undefined


        if (dataExplorerSettings === null || dataExplorerSettings === undefined) {
            throw new Error('Required parameter dataExplorerSettings was null or undefined when calling setDataExplorerSettings.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(dataExplorerSettings, "DataExplorerSettings"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Set the bounding boxes for a sample
     * @summary Set bounding boxes
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param sampleBoundingBoxesRequest 
     */
    public async setSampleBoundingBoxes (projectId: number, sampleId: number, sampleBoundingBoxesRequest: SampleBoundingBoxesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/bounding-boxes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleBoundingBoxes.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleBoundingBoxes.');
        }

        // verify required parameter 'sampleBoundingBoxesRequest' is not null or undefined


        if (sampleBoundingBoxesRequest === null || sampleBoundingBoxesRequest === undefined) {
            throw new Error('Required parameter sampleBoundingBoxesRequest was null or undefined when calling setSampleBoundingBoxes.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(sampleBoundingBoxesRequest, "SampleBoundingBoxesRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Adds or updates the metadata associated to a sample.
     * @summary Set sample metadata
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleMetadataRequest 
     */
    public async setSampleMetadata (projectId: number, sampleId: number, setSampleMetadataRequest: SetSampleMetadataRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/metadata'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleMetadata.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleMetadata.');
        }

        // verify required parameter 'setSampleMetadataRequest' is not null or undefined


        if (setSampleMetadataRequest === null || setSampleMetadataRequest === undefined) {
            throw new Error('Required parameter setSampleMetadataRequest was null or undefined when calling setSampleMetadata.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setSampleMetadataRequest, "SetSampleMetadataRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Queue up changes to an object as part of the AI Actions flow. This overwrites any previous proposed changes.
     * @summary Propose changes
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleProposedChangesRequest 
     */
    public async setSampleProposedChanges (projectId: number, sampleId: number, setSampleProposedChangesRequest: SetSampleProposedChangesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/propose-changes'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleProposedChanges.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleProposedChanges.');
        }

        // verify required parameter 'setSampleProposedChangesRequest' is not null or undefined


        if (setSampleProposedChangesRequest === null || setSampleProposedChangesRequest === undefined) {
            throw new Error('Required parameter setSampleProposedChangesRequest was null or undefined when calling setSampleProposedChanges.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setSampleProposedChangesRequest, "SetSampleProposedChangesRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Set structured labels for a sample. If a sample has structured labels the `label` column is ignored, and the sample is allowed to have multiple labels. An array of { startIndex, endIndex, label } needs to be passed in with labels for the complete sample (see `valuesCount` to get the upper bound). endIndex is _inclusive_. If you pass in an incorrect array (e.g. missing values) you\'ll get an error back.
     * @summary Update structured labels
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleStructuredLabelsRequest 
     */
    public async setSampleStructuredLabels (projectId: number, sampleId: number, setSampleStructuredLabelsRequest: SetSampleStructuredLabelsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/structured-labels'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleStructuredLabels.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleStructuredLabels.');
        }

        // verify required parameter 'setSampleStructuredLabelsRequest' is not null or undefined


        if (setSampleStructuredLabelsRequest === null || setSampleStructuredLabelsRequest === undefined) {
            throw new Error('Required parameter setSampleStructuredLabelsRequest was null or undefined when calling setSampleStructuredLabels.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setSampleStructuredLabelsRequest, "SetSampleStructuredLabelsRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Update the video dimensions for a sample. This is only available for video files that do not have dimensions set yet.
     * @summary Set sample video dimensions
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param setSampleVideoDimensionsRequest 
     */
    public async setSampleVideoDimensions (projectId: number, sampleId: number, setSampleVideoDimensionsRequest: SetSampleVideoDimensionsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/video-dimensions'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setSampleVideoDimensions.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling setSampleVideoDimensions.');
        }

        // verify required parameter 'setSampleVideoDimensionsRequest' is not null or undefined


        if (setSampleVideoDimensionsRequest === null || setSampleVideoDimensionsRequest === undefined) {
            throw new Error('Required parameter setSampleVideoDimensionsRequest was null or undefined when calling setSampleVideoDimensions.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(setSampleVideoDimensionsRequest, "SetSampleVideoDimensionsRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Split a video sample into individual frames. Depending on the length of the video sample this will either execute immediately or return the ID of a job that will perform this action. 
     * @summary Split sample into frames
     * @param projectId Project ID
     * @param sampleId Sample ID
     * @param splitSampleInFramesRequest 
     */
    public async splitSampleInFrames (projectId: number, sampleId: number, splitSampleInFramesRequest: SplitSampleInFramesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse | StartJobResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/{sampleId}/split'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'sampleId' + '}', encodeURIComponent(String(sampleId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling splitSampleInFrames.');
        }

        // verify required parameter 'sampleId' is not null or undefined


        if (sampleId === null || sampleId === undefined) {
            throw new Error('Required parameter sampleId was null or undefined when calling splitSampleInFrames.');
        }

        // verify required parameter 'splitSampleInFramesRequest' is not null or undefined


        if (splitSampleInFramesRequest === null || splitSampleInFramesRequest === undefined) {
            throw new Error('Required parameter splitSampleInFramesRequest was null or undefined when calling splitSampleInFrames.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(splitSampleInFramesRequest, "SplitSampleInFramesRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse | StartJobResponse'
        );
    }

    /**
     * When segmenting a sample into smaller segments, store the segment length to ensure uniform segment lengths.
     * @summary Store the last segment length
     * @param projectId Project ID
     * @param storeSegmentLengthRequest 
     */
    public async storeSegmentLength (projectId: number, storeSegmentLengthRequest: StoreSegmentLengthRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/store-segment-length'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling storeSegmentLength.');
        }

        // verify required parameter 'storeSegmentLengthRequest' is not null or undefined


        if (storeSegmentLengthRequest === null || storeSegmentLengthRequest === undefined) {
            throw new Error('Required parameter storeSegmentLengthRequest was null or undefined when calling storeSegmentLength.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(storeSegmentLengthRequest, "StoreSegmentLengthRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }

    /**
     * Track objects between two samples. Source sample should have bounding boxes set.
     * @summary Track objects
     * @param projectId Project ID
     * @param trackObjectsRequest 
     */
    public async trackObjects (projectId: number, trackObjectsRequest: TrackObjectsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<TrackObjectsResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/track-objects'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling trackObjects.');
        }

        // verify required parameter 'trackObjectsRequest' is not null or undefined


        if (trackObjectsRequest === null || trackObjectsRequest === undefined) {
            throw new Error('Required parameter trackObjectsRequest was null or undefined when calling trackObjects.');
        }

        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };

        localVarRequestOptions.body = JSON.stringify(ObjectSerializer.serialize(trackObjectsRequest, "TrackObjectsRequest"));


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'TrackObjectsResponse'
        );
    }

    /**
     * Used internally (from a data pipeline) to upload a picture of the data explorer
     * @summary Upload a data explorer screenshot
     * @param projectId Project ID
     * @param image 
     */
    public async uploadDataExplorerScreenshot (projectId: number, params: uploadDataExplorerScreenshotFormParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<GenericApiResponse> {
        const localVarPath = this.basePath + '/api/{projectId}/raw-data/data-explorer/screenshot'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: Record<string, string> = {};
        let localVarHeaderParams: Record<string, string> = {
            'User-Agent': 'edgeimpulse-api nodejs',
            'Content-Type': 'application/json',
            ...this.defaultHeaders,
        };
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: Record<string, string> | FormData | UndiciFormData | undefined;

        // verify required parameter 'projectId' is not null or undefined


        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling uploadDataExplorerScreenshot.');
        }

        // verify required parameter 'image' is not null or undefined
        if (params.image === null || params.image === undefined) {
            throw new Error('Required parameter params.image was null or undefined when calling uploadDataExplorerScreenshot.');
        }



        localVarHeaderParams = {
            ...localVarHeaderParams,
            ...options.headers,
            ...this.opts.extraHeaders,
        };

        if (params.image !== undefined) {
            if (!(localVarFormParams instanceof FormData)) {
                const existingParams = localVarFormParams;
                localVarFormParams = new FormData();

                if (existingParams && typeof existingParams === 'object') {
                    Object.keys(existingParams).forEach(key => {
                        (localVarFormParams as FormData).append(key, (existingParams as Record<string, string>)[key]);
                    });
                }
            }

            const imageFiles = Array.isArray(params.image) ? params.image : [params.image];

            const Blob = globalThis.Blob || require('buffer').Blob;
            imageFiles.forEach((f) => {
                (localVarFormParams as FormData).append('image', new Blob([f.value], {
                    type: f.options.contentType
                }), f.options.filename);
            });
        }
        const queryString = Object.entries(localVarQueryParameters)
            .filter(([, value]) => value !== undefined)
            .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)
            .join('&');

        let localVarUrl = localVarPath + (queryString ? `?${queryString}` : '');
        let localVarRequestOptions: RequestOptionsType = {
            method: 'POST',
            headers: { ...localVarHeaderParams },
        };


        let requestOptions = localVarRequestOptions;
        let url = localVarUrl;
        const auth_ApiKeyAuthentication = await this.authentications.ApiKeyAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_ApiKeyAuthentication.requestOptions;
        url = auth_ApiKeyAuthentication.url;

        const auth_JWTAuthentication = await this.authentications.JWTAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTAuthentication.requestOptions;
        url = auth_JWTAuthentication.url;

        const auth_JWTHttpHeaderAuthentication = await this.authentications.JWTHttpHeaderAuthentication.applyToRequest(requestOptions, url);
        requestOptions = auth_JWTHttpHeaderAuthentication.requestOptions;
        url = auth_JWTHttpHeaderAuthentication.url;

        const auth_OAuth2 = await this.authentications.OAuth2.applyToRequest(requestOptions, url);
        requestOptions = auth_OAuth2.requestOptions;
        url = auth_OAuth2.url;

        const authDefault = await this.authentications.default.applyToRequest(requestOptions, url);
        requestOptions = authDefault.requestOptions;
        url = authDefault.url;

        if (localVarFormParams) {
            delete requestOptions.headers['Content-Type'];
            if (localVarFormParams instanceof FormData) {
                // FormData: fetch will handle Content-Type automatically.
                requestOptions.body = localVarFormParams;
            }
            else if (Object.keys(localVarFormParams).length > 0) {
                // URL-encoded form
                requestOptions.body = new URLSearchParams(localVarFormParams as Record<string, string>).toString();
                requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }

        const response = await fetch(url, requestOptions);
        return this.handleResponse(
            response,
            'GenericApiResponse'
        );
    }
}
